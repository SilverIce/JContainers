diff --git a/JContainers/.gitignore b/JContainers/.gitignore
new file mode 100644
index 0000000..6100fc7
--- /dev/null
+++ b/JContainers/.gitignore
@@ -0,0 +1,10 @@
+
+#################
+## Visual Studio
+#################
+
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+
+[Dd]ebug/
+[Rr]elease/
diff --git a/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/api_for_lua.h b/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/api_for_lua.h
index 8d8ec95..bef42c2 100644
--- a/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/api_for_lua.h
+++ b/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/api_for_lua.h
@@ -68,5 +68,6 @@ CString JMap_nextKey(handle, cstring lastKey);
 CForm JFormMap_nextKey(handle obj, CForm lastKey);
 void JFormMap_setValue(handle obj, CForm key, const JCValue* val);
 JCToLuaValue JFormMap_getValue(handle obj, CForm key);
+void JFormMap_removeKey(handle obj, CForm key);
 
 handle JDB_instance(handle jc_context);
diff --git a/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/init.lua b/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/init.lua
index 665b9a2..5c6f8dc 100644
--- a/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/init.lua
+++ b/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/init.lua
@@ -184,7 +184,7 @@ local function makeEvalLuaFunction()
   local function compileAndCache (luaString)
     local func = jc_function_cache[luaString]
     if not func then
-      local f, message = loadstring('local jobject = ... ;' .. luaString)
+      local f, message = loadstring('local args = ...; local jobject = args;' .. luaString)
       if f then
         func = f
         setfenv(f, evallua_sandbox)
diff --git a/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/jc.lua b/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/jc.lua
index f1281fc..4b23e5f 100644
--- a/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/jc.lua
+++ b/JContainers/Data/SKSE/Plugins/JCData/InternalLuaScripts/jc.lua
@@ -116,7 +116,7 @@ local JMapNativeFuncs = retrieveNativeFunctions('JMap',
 local JFormMapNativeFuncs = retrieveNativeFunctions('JFormMap',
     {
       object = {'handle'},
-      removeKey = {'bool', 'handle, CForm'},
+      -- not usable anymore: removeKey = {'bool', 'handle, CForm'},
       allKeys = {'handle', 'handle'},
       allValues = {'handle', 'handle'},
     }
@@ -415,7 +415,7 @@ do
     if value then
       jclib.JFormMap_setValue(optr.___id, key, returnJCValue(value))
     else
-      JFormMapNativeFuncs.removeKey(optr.___id, key)
+      jclib.JFormMap_removeKey(optr.___id, key)
     end
   end
 
diff --git a/JContainers/Data/SKSE/Plugins/JCData/lua/testing/basic.lua b/JContainers/Data/SKSE/Plugins/JCData/lua/testing/basic.lua
index 77d2891..9a10e82 100644
--- a/JContainers/Data/SKSE/Plugins/JCData/lua/testing/basic.lua
+++ b/JContainers/Data/SKSE/Plugins/JCData/lua/testing/basic.lua
@@ -1,6 +1,9 @@
 
 local JCTypeList = {JArray, JMap, JFormMap}
 
+local function print( ... )
+end
+
 return function()
   
   do
diff --git a/JContainers/JContainers.aps b/JContainers/JContainers.aps
index e75007d..46c1e6f 100644
Binary files a/JContainers/JContainers.aps and b/JContainers/JContainers.aps differ
diff --git a/JContainers/JContainers.rc b/JContainers/JContainers.rc
index 170b019..a7402b7 100644
Binary files a/JContainers/JContainers.rc and b/JContainers/JContainers.rc differ
diff --git a/JContainers/JContainers.vcxproj b/JContainers/JContainers.vcxproj
index ee67112..1272d11 100644
--- a/JContainers/JContainers.vcxproj
+++ b/JContainers/JContainers.vcxproj
@@ -64,15 +64,15 @@
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <ClCompile>
-      <Optimization>Full</Optimization>
+      <Optimization>MinSpace</Optimization>
       <IntrinsicFunctions>true</IntrinsicFunctions>
-      <AdditionalIncludeDirectories>src;$(SolutionDir)\dep\boost;$(SolutionDir)\dep;$(SolutionDir)\dep\skse;$(SolutionDir)\dep\jansson\jansson\src;$(SolutionDir)\dep\jansson;$(SolutionDir)\dep\luajit\luajit-2.0\src;$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;NO_JC_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>src;$(SolutionDir)\dep\boost;$(SolutionDir)\dep;$(SolutionDir)\dep\skse;$(SolutionDir)\dep\googletest\googletest\googletest\include;$(SolutionDir)\dep\jansson\jansson\src;$(SolutionDir)\dep\jansson;$(SolutionDir)\dep\luajit\luajit-2.0\src;$(ProjectDir)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;BOOST_HAS_HASH;NO_JC_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
       <PrecompiledHeader>Use</PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
-      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
       <StringPooling>true</StringPooling>
       <PrecompiledHeaderFile>jcontainers_pch.h</PrecompiledHeaderFile>
       <ForcedIncludeFiles>jcontainers_pch.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
@@ -87,7 +87,6 @@
       <AdditionalLibraryDirectories>..\dep\boost\boost_lib\lib</AdditionalLibraryDirectories>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Console</SubSystem>
-      <Version>0.66</Version>
     </Link>
     <PostBuildEvent />
     <Bscmake />
@@ -99,8 +98,8 @@
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>src;$(SolutionDir)\dep\boost;$(SolutionDir)\dep;$(SolutionDir)\dep\skse;$(SolutionDir)\dep\jansson\jansson\src;$(SolutionDir)\dep\jansson;$(SolutionDir)\dep\luajit\luajit-2.0\src;$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>src;$(SolutionDir)\dep\boost;$(SolutionDir)\dep;$(SolutionDir)\dep\skse;$(SolutionDir)\dep\googletest\googletest\googletest\include;$(SolutionDir)\dep\jansson\jansson\src;$(SolutionDir)\dep\jansson;$(SolutionDir)\dep\luajit\luajit-2.0\src;$(ProjectDir)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;BOOST_HAS_HASH;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
       <PrecompiledHeader>Use</PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
@@ -132,26 +131,25 @@
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemGroup>
-    <ClCompile Include="src\api_3\tes_inteface.cpp" />
+    <ClCompile Include="src\api_3\string_wrapper.cpp" />
+    <ClCompile Include="src\api_3\tes_api_3.cpp" />
+    <ClCompile Include="src\collections\collections.cpp" />
+    <ClCompile Include="src\collections\lua_module.cpp" />
+    <ClCompile Include="src\collections\access.cpp" />
     <ClCompile Include="src\object\object_module.cpp" />
-    <ClCompile Include="src\skse_api.cpp" />
+    <ClCompile Include="src\reflection\detail\reflection.cpp" />
+    <ClCompile Include="src\skse\skse.cpp" />
+    <ClCompile Include="src\skse_callbacks.cpp" />
     <ClCompile Include="src\testing_api.cpp" />
     <ClCompile Include="src\jc_interface.cpp" />
-    <ClCompile Include="src\lua_module.cpp" />
-    <ClCompile Include="src\gtest.cpp" />
     <ClCompile Include="src\jcontainers_pch.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
     </ClCompile>
-    <ClCompile Include="src\path_resolving.cpp" />
-    <ClCompile Include="src\reflection.cpp" />
-    <ClCompile Include="src\collections.cpp" />
-    <ClCompile Include="src\skse.cpp" />
-    <ClCompile Include="src\string_wrapper.cpp" />
+    <ClCompile Include="src\util\logging.cpp" />
     <ClCompile Include="src\util\util.cpp" />
     <ClInclude Include="Data\SKSE\Plugins\JCData\InternalLuaScripts\api_for_lua.h" />
     <ClInclude Include="resource.h" />
-    <ClInclude Include="src\api_3\collections.tests.hpp" />
     <ClInclude Include="src\api_3\master.h" />
     <ClInclude Include="src\api_3\tes_array.h" />
     <ClInclude Include="src\api_3\tes_db.h" />
@@ -161,20 +159,27 @@
     <ClInclude Include="src\api_3\tes_map.h" />
     <ClInclude Include="src\api_3\tes_object.h" />
     <ClInclude Include="src\api_3\tes_string.h" />
-    <ClInclude Include="src\boost_extras.h" />
-    <ClInclude Include="src\code_producer.hpp" />
-    <ClInclude Include="src\collections.tests.base.h" />
-    <ClInclude Include="src\collection_bind_traits.h" />
-    <ClInclude Include="src\collection_copying.h" />
-    <ClInclude Include="src\collection_item.h" />
-    <ClInclude Include="src\collection_operators.h" />
-    <ClInclude Include="src\collection_types.h" />
-    <ClInclude Include="src\form_handling.h" />
-    <ClInclude Include="src\collection_functions.h" />
-    <ClInclude Include="src\intrusive_ptr.hpp" />
+    <ClInclude Include="src\collections\collections.h" />
+    <ClInclude Include="src\collections\default_value.h" />
+    <ClInclude Include="src\collections\dyn_form_watcher.h" />
+    <ClInclude Include="src\collections\dyn_form_watcher.hpp" />
+    <ClInclude Include="src\collections\tests.h" />
+    <ClInclude Include="src\collections\bind_traits.h" />
+    <ClInclude Include="src\collections\copying.h" />
+    <ClInclude Include="src\collections\functions.h" />
+    <ClInclude Include="src\collections\item.h" />
+    <ClInclude Include="src\collections\operators.h" />
+    <ClInclude Include="src\collections\form_handling.h" />
+    <ClInclude Include="src\collections\json_serialization.h" />
+    <ClInclude Include="src\collections\lua_module.h" />
+    <ClInclude Include="src\collections\lua_native_funcs.hpp" />
+    <ClInclude Include="src\collections\access.h" />
+    <ClInclude Include="src\collections\context.h" />
+    <ClInclude Include="src\collections\context.hpp" />
+    <ClInclude Include="src\collections\error_code.h" />
+    <ClInclude Include="src\form_id.h" />
+    <ClInclude Include="src\iarchive_with_blob.h" />
     <ClInclude Include="src\jc_interface.h" />
-    <ClInclude Include="src\lua_module.h" />
-    <ClInclude Include="src\lua_native_funcs.hpp" />
     <ClInclude Include="src\object\autorelease_queue.h" />
     <ClInclude Include="src\object\garbage_collector.h" />
     <ClInclude Include="src\object\id_generator.h" />
@@ -184,33 +189,35 @@
     <ClInclude Include="src\object\object_context.h" />
     <ClInclude Include="src\object\object_context.hpp" />
     <ClInclude Include="src\object\object_registry.h" />
-    <ClInclude Include="src\path_resolving.h" />
     <ClInclude Include="src\jcontainers_constants.h" />
-    <ClInclude Include="src\skse.h" />
-    <ClInclude Include="src\reflection.h" />
-    <ClInclude Include="src\skse_papyrus_args.hpp" />
-    <ClInclude Include="src\skse_string.h" />
+    <ClInclude Include="src\reflection\detail\code_producer.hpp" />
+    <ClInclude Include="src\reflection\detail\type_traits.hpp" />
+    <ClInclude Include="src\reflection\reflection.h" />
+    <ClInclude Include="src\reflection\tes_binding.h" />
+    <ClInclude Include="src\skse\skse.h" />
+    <ClInclude Include="src\skse\papyrus_args.hpp" />
+    <ClInclude Include="src\skse\string.h" />
     <ClInclude Include="src\typedefs.h" />
+    <ClInclude Include="src\util\atomic_serialization.h" />
     <ClInclude Include="src\util\istring.h" />
     <ClInclude Include="src\util\istring_serialization.h" />
+    <ClInclude Include="src\util\singleton.h" />
     <ClInclude Include="src\util\spinlock.h" />
+    <ClInclude Include="src\util\stl_ext.h" />
     <ClInclude Include="src\util\util.h" />
   </ItemGroup>
   <ItemGroup>
-    <ClInclude Include="src\collections.h" />
     <ClInclude Include="src\gtest.h" />
     <ClInclude Include="src\jcontainers_pch.h" />
-    <ClInclude Include="src\json_handling.h" />
     <ClInclude Include="src\meta.h" />
-    <ClInclude Include="src\tes_binding.h" />
-    <ClInclude Include="src\tes_context.h" />
-    <ClInclude Include="src\tes_context.hpp" />
-    <ClInclude Include="src\tes_error_code.h" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\dep\common\common.vcxproj">
       <Project>{20c6411c-596f-4b85-be4e-8bc91f59d8a6}</Project>
     </ProjectReference>
+    <ProjectReference Include="..\dep\googletest\gtest.vcxproj">
+      <Project>{c8f6c172-56f2-4e76-b5fa-c3b423b31be7}</Project>
+    </ProjectReference>
     <ProjectReference Include="..\dep\jansson\jansson.vcxproj">
       <Project>{f9ef3ca7-06a8-4bb2-9232-c4251e65829b}</Project>
     </ProjectReference>
@@ -225,8 +232,6 @@
     <ResourceCompile Include="JContainers.rc" />
   </ItemGroup>
   <ItemGroup>
-    <None Include="Data\SKSE\Plugins\JCData\InternalLuaScripts\init.lua" />
-    <None Include="Data\SKSE\Plugins\JCData\InternalLuaScripts\jc.lua" />
     <None Include="jc_debug.py" />
   </ItemGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
diff --git a/JContainers/JContainers.vcxproj.filters b/JContainers/JContainers.vcxproj.filters
index b86c481..de2cda6 100644
--- a/JContainers/JContainers.vcxproj.filters
+++ b/JContainers/JContainers.vcxproj.filters
@@ -7,12 +7,6 @@
     <Filter Include="object_module">
       <UniqueIdentifier>{36211b98-169e-46fc-961c-48122146285c}</UniqueIdentifier>
     </Filter>
-    <Filter Include="collections_module">
-      <UniqueIdentifier>{2c083f8d-8546-477b-851e-5eb515359766}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="collections_module\path_resolving">
-      <UniqueIdentifier>{3411d9ab-af92-4e3d-bc27-14589afe0710}</UniqueIdentifier>
-    </Filter>
     <Filter Include="skse">
       <UniqueIdentifier>{ca106175-46ec-41d4-a025-c06319331cdf}</UniqueIdentifier>
     </Filter>
@@ -22,48 +16,27 @@
     <Filter Include="plugin_interface">
       <UniqueIdentifier>{14edfebb-ae9f-4369-bd9f-3b374e3a73ba}</UniqueIdentifier>
     </Filter>
-    <Filter Include="collections_module\lua">
-      <UniqueIdentifier>{bc4ac5ac-882f-4d98-a11d-e0f0d63cb96f}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="collections_module\tes_api_3">
-      <UniqueIdentifier>{a481ff76-9ab2-4bb4-91f6-f5d5e21c603c}</UniqueIdentifier>
-    </Filter>
     <Filter Include="util">
       <UniqueIdentifier>{b2bd77e9-b73b-4846-b0e6-6ae153b3c7f1}</UniqueIdentifier>
     </Filter>
     <Filter Include="object_module\impl">
       <UniqueIdentifier>{eb23fa71-0ac8-43dc-8357-dd4915bbcfd6}</UniqueIdentifier>
     </Filter>
+    <Filter Include="reflection\detail">
+      <UniqueIdentifier>{bd7824e4-2e9a-4491-903f-a8f7d679474f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="collections">
+      <UniqueIdentifier>{2c083f8d-8546-477b-851e-5eb515359766}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="tes_api_3">
+      <UniqueIdentifier>{a481ff76-9ab2-4bb4-91f6-f5d5e21c603c}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
-    <ClCompile Include="src\gtest.cpp">
-      <Filter>gtest</Filter>
-    </ClCompile>
     <ClCompile Include="src\jcontainers_pch.cpp" />
-    <ClCompile Include="src\path_resolving.cpp">
-      <Filter>collections_module\path_resolving</Filter>
-    </ClCompile>
-    <ClCompile Include="src\skse.cpp">
-      <Filter>skse</Filter>
-    </ClCompile>
-    <ClCompile Include="src\reflection.cpp">
-      <Filter>reflection</Filter>
-    </ClCompile>
     <ClCompile Include="src\jc_interface.cpp">
       <Filter>plugin_interface</Filter>
     </ClCompile>
-    <ClCompile Include="src\string_wrapper.cpp">
-      <Filter>collections_module</Filter>
-    </ClCompile>
-    <ClCompile Include="src\api_3\tes_inteface.cpp">
-      <Filter>collections_module</Filter>
-    </ClCompile>
-    <ClCompile Include="src\lua_module.cpp">
-      <Filter>collections_module\lua</Filter>
-    </ClCompile>
-    <ClCompile Include="src\collections.cpp">
-      <Filter>collections_module</Filter>
-    </ClCompile>
     <ClCompile Include="src\testing_api.cpp">
       <Filter>plugin_interface</Filter>
     </ClCompile>
@@ -73,26 +46,35 @@
     <ClCompile Include="src\object\object_module.cpp">
       <Filter>object_module\impl</Filter>
     </ClCompile>
-    <ClCompile Include="src\skse_api.cpp">
+    <ClCompile Include="src\reflection\detail\reflection.cpp">
+      <Filter>reflection\detail</Filter>
+    </ClCompile>
+    <ClCompile Include="src\skse\skse.cpp">
+      <Filter>skse</Filter>
+    </ClCompile>
+    <ClCompile Include="src\collections\collections.cpp">
+      <Filter>collections</Filter>
+    </ClCompile>
+    <ClCompile Include="src\collections\lua_module.cpp">
+      <Filter>collections</Filter>
+    </ClCompile>
+    <ClCompile Include="src\collections\access.cpp">
+      <Filter>collections</Filter>
+    </ClCompile>
+    <ClCompile Include="src\api_3\string_wrapper.cpp">
+      <Filter>tes_api_3</Filter>
+    </ClCompile>
+    <ClCompile Include="src\api_3\tes_api_3.cpp">
+      <Filter>tes_api_3</Filter>
+    </ClCompile>
+    <ClCompile Include="src\skse_callbacks.cpp">
       <Filter>plugin_interface</Filter>
     </ClCompile>
+    <ClCompile Include="src\util\logging.cpp">
+      <Filter>util</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
-    <ClInclude Include="src\collections.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\json_handling.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\tes_error_code.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\tes_context.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\tes_context.hpp">
-      <Filter>collections_module</Filter>
-    </ClInclude>
     <ClInclude Include="src\gtest.h">
       <Filter>gtest</Filter>
     </ClInclude>
@@ -100,90 +82,12 @@
       <Filter>gtest</Filter>
     </ClInclude>
     <ClInclude Include="src\typedefs.h" />
-    <ClInclude Include="src\form_handling.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\collection_operators.h">
-      <Filter>collections_module\path_resolving</Filter>
-    </ClInclude>
-    <ClInclude Include="src\path_resolving.h">
-      <Filter>collections_module\path_resolving</Filter>
-    </ClInclude>
-    <ClInclude Include="src\boost_extras.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\skse.h">
-      <Filter>skse</Filter>
-    </ClInclude>
     <ClInclude Include="src\jcontainers_constants.h" />
-    <ClInclude Include="src\tes_binding.h">
-      <Filter>reflection</Filter>
-    </ClInclude>
-    <ClInclude Include="src\reflection.h">
-      <Filter>reflection</Filter>
-    </ClInclude>
-    <ClInclude Include="src\collection_bind_traits.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
     <ClInclude Include="src\jcontainers_pch.h" />
-    <ClInclude Include="src\code_producer.hpp">
-      <Filter>reflection</Filter>
-    </ClInclude>
     <ClInclude Include="resource.h" />
     <ClInclude Include="src\jc_interface.h">
       <Filter>plugin_interface</Filter>
     </ClInclude>
-    <ClInclude Include="src\api_3\tes_array.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\tes_db.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\tes_form_db.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\tes_jcontainers.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\tes_lua.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\tes_map.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\tes_object.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\tes_string.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\collections.tests.hpp">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\api_3\master.h">
-      <Filter>collections_module\tes_api_3</Filter>
-    </ClInclude>
-    <ClInclude Include="src\collection_functions.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="Data\SKSE\Plugins\JCData\InternalLuaScripts\api_for_lua.h">
-      <Filter>collections_module\lua</Filter>
-    </ClInclude>
-    <ClInclude Include="src\collections.tests.base.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\lua_module.h">
-      <Filter>collections_module\lua</Filter>
-    </ClInclude>
-    <ClInclude Include="src\lua_native_funcs.hpp">
-      <Filter>collections_module\lua</Filter>
-    </ClInclude>
-    <ClInclude Include="src\collection_copying.h">
-      <Filter>collections_module</Filter>
-    </ClInclude>
-    <ClInclude Include="src\intrusive_ptr.hpp">
-      <Filter>collections_module</Filter>
-    </ClInclude>
     <ClInclude Include="src\util\spinlock.h">
       <Filter>util</Filter>
     </ClInclude>
@@ -220,32 +124,130 @@
     <ClInclude Include="src\object\id_generator.h">
       <Filter>object_module\impl</Filter>
     </ClInclude>
-    <ClInclude Include="src\collection_item.h">
-      <Filter>collections_module</Filter>
+    <ClInclude Include="src\util\istring_serialization.h">
+      <Filter>util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\reflection\reflection.h">
+      <Filter>reflection</Filter>
+    </ClInclude>
+    <ClInclude Include="src\reflection\tes_binding.h">
+      <Filter>reflection</Filter>
     </ClInclude>
-    <ClInclude Include="src\collection_types.h">
-      <Filter>collections_module</Filter>
+    <ClInclude Include="src\reflection\detail\code_producer.hpp">
+      <Filter>reflection\detail</Filter>
     </ClInclude>
-    <ClInclude Include="src\skse_string.h">
+    <ClInclude Include="src\skse\skse.h">
       <Filter>skse</Filter>
     </ClInclude>
-    <ClInclude Include="src\skse_papyrus_args.hpp">
+    <ClInclude Include="src\skse\string.h">
       <Filter>skse</Filter>
     </ClInclude>
-    <ClInclude Include="src\util\istring_serialization.h">
+    <ClInclude Include="src\skse\papyrus_args.hpp">
+      <Filter>skse</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\collections.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\form_handling.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\lua_module.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\lua_native_funcs.hpp">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\access.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\functions.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\copying.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\operators.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\context.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\context.hpp">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\error_code.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\bind_traits.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\item.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\json_serialization.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\master.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_array.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_db.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_form_db.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_jcontainers.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_lua.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_map.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_object.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\api_3\tes_string.h">
+      <Filter>tes_api_3</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\tests.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\reflection\detail\type_traits.hpp">
+      <Filter>reflection\detail</Filter>
+    </ClInclude>
+    <ClInclude Include="src\collections\dyn_form_watcher.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\atomic_serialization.h">
       <Filter>util</Filter>
     </ClInclude>
+    <ClInclude Include="src\form_id.h" />
+    <ClInclude Include="src\collections\dyn_form_watcher.hpp">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\singleton.h">
+      <Filter>util</Filter>
+    </ClInclude>
+    <ClInclude Include="Data\SKSE\Plugins\JCData\InternalLuaScripts\api_for_lua.h">
+      <Filter>collections</Filter>
+    </ClInclude>
+    <ClInclude Include="src\util\stl_ext.h">
+      <Filter>util</Filter>
+    </ClInclude>
+    <ClInclude Include="src\iarchive_with_blob.h" />
+    <ClInclude Include="src\collections\default_value.h">
+      <Filter>collections</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="JContainers.rc" />
   </ItemGroup>
   <ItemGroup>
-    <None Include="Data\SKSE\Plugins\JCData\InternalLuaScripts\jc.lua">
-      <Filter>collections_module\lua</Filter>
-    </None>
-    <None Include="Data\SKSE\Plugins\JCData\InternalLuaScripts\init.lua">
-      <Filter>collections_module\lua</Filter>
-    </None>
     <None Include="jc_debug.py" />
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/JContainers/jc_debug.py b/JContainers/jc_debug.py
index 0ee6a33..c502223 100644
--- a/JContainers/jc_debug.py
+++ b/JContainers/jc_debug.py
@@ -1,15 +1,21 @@
 import os
 import sys
+import ctypes
 
 class JCLib(object):
     def __init__(self, location):
-        import ctypes
         from ctypes import cdll
-        print 'loading JCLib at:', location
-        self.lib = cdll.LoadLibrary(location);
+        print('loading JCLib at:', location)
+        self.lib = cdll.LoadLibrary(location)
 
-    def runTests(self):
-        self.lib.JC_runTests()
+    def runTests(self, args):
+        print(len(args))
+        stringArray = (ctypes.c_char_p * len(args))()
+        for i in range(len(args)):
+            stringArray[i] = args[i].encode('utf-8')
+
+        succeed = self.lib.JC_runTests(len(args), ctypes.byref(stringArray))
+        print('The tests succeed', succeed)
 
 
 if __name__ == '__main__':
@@ -18,18 +24,20 @@ if __name__ == '__main__':
     # location = sys.argv[1]
     # lib = JCLib(location)
     # lib.runTests()
+        
+    args = ('', '--gtest_filter=form_entry_ref._',)
 
     try:
-        print sys.argv
+        print(sys.argv)
         location = sys.argv[1]
         lib = JCLib(location)
-        lib.runTests()
+        lib.runTests(args)
     except BaseException as e:
-        print 'Error:', e
+        print('Error:', e)
         #raise
     except:
-        print "Unexpected error:", sys.exc_info()[0]
+        print("Unexpected error:", sys.exc_info()[0])
         #raise
 
-    input("Press Enter to continue...")
+    input("Press Enter to close...")
 
diff --git a/JContainers/src/api_3/master.h b/JContainers/src/api_3/master.h
index 264b5e0..ab03877 100644
--- a/JContainers/src/api_3/master.h
+++ b/JContainers/src/api_3/master.h
@@ -20,4 +20,4 @@ namespace tes_api_3 {
 #include "api_3/tes_form_db.h"
 #include "api_3/tes_lua.h"
 
-#include "api_3/collections.tests.hpp"
+#include "api_3/tests.hpp"
diff --git a/JContainers/src/string_wrapper.cpp b/JContainers/src/api_3/string_wrapper.cpp
similarity index 100%
rename from JContainers/src/string_wrapper.cpp
rename to JContainers/src/api_3/string_wrapper.cpp
diff --git a/JContainers/src/api_3/tes_inteface.cpp b/JContainers/src/api_3/tes_api_3.cpp
similarity index 56%
rename from JContainers/src/api_3/tes_inteface.cpp
rename to JContainers/src/api_3/tes_api_3.cpp
index 76192a8..6cf71de 100644
--- a/JContainers/src/api_3/tes_inteface.cpp
+++ b/JContainers/src/api_3/tes_api_3.cpp
@@ -18,22 +18,22 @@
 #include "util/util.h"
 #include "jcontainers_constants.h"
 
-#include "skse_string.h"
-#include "skse_papyrus_args.hpp"
+#include "skse/string.h"
+#include "skse/papyrus_args.hpp"
 #include "object/object_context.h"
 #include "object/object_base.h"
 
-#include "tes_error_code.h"
-#include "tes_context.h"
-#include "collections.h"
+#include "collections/error_code.h"
+#include "collections/context.h"
+#include "collections/collections.h"
 
-#include "json_handling.h"
-#include "collection_copying.h"
-#include "path_resolving.h"
+#include "collections/json_serialization.h"
+#include "collections/copying.h"
+#include "collections/access.h"
 
-#include "collection_bind_traits.h"
+#include "collections/bind_traits.h"
+#include "collections/tests.h"
 
-#include "collections.tests.base.h"
 #include "api_3/master.h"
 
 namespace collections {
diff --git a/JContainers/src/api_3/tes_array.h b/JContainers/src/api_3/tes_array.h
index af18820..3c1883e 100644
--- a/JContainers/src/api_3/tes_array.h
+++ b/JContainers/src/api_3/tes_array.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#include "collection_functions.h"
+#include "collections/functions.h"
 
 namespace tes_api_3 {
 
@@ -50,13 +50,14 @@ namespace tes_api_3 {
         }
         REGISTERF2(objectWithSize, "size", "creates array of given size, filled with empty items");
 
-        template<class T>
-        static object_base* fromArray(VMArray<T> arr) {
+        template<class TesType, class JCType = TesType>
+        static object_base* fromArray(VMArray<TesType> arr) {
             auto obj = &array::objectWithInitializer([&](array &me) {
+                me.u_container().reserve(arr.Length());
                 for (UInt32 i = 0; i < arr.Length(); ++i) {
-                    T val;
+                    TesType val;
                     arr.Get(&val, i);
-                    me._array.push_back(item(val));
+                    me.u_container().emplace_back(reflection::binding::get_converter<JCType>::convert2J(val));
                 }
             },
                 tes_context::instance());
@@ -69,6 +70,7 @@ objectWithBooleans converts booleans into integers");
         REGISTERF(fromArray<skse::string_ref>, "objectWithStrings",  "values", nullptr);
         REGISTERF(fromArray<Float32>, "objectWithFloats",  "values", nullptr);
         REGISTERF(fromArray<bool>, "objectWithBooleans",  "values", nullptr);
+        REGISTERF(ARGS(fromArray<TESForm*, form_ref>), "objectWithForms", "values", nullptr);
 
         static object_base* subArray(ref source, SInt32 startIndex, SInt32 endIndex) {
             if (!source) {
@@ -113,24 +115,25 @@ NEGATIVE_IDX_COMMENT);
             struct inserter : BGSListForm::Visitor {
 
                 virtual bool Accept(TESForm * form) override {
-                    arr->u_container().insert(arr->u_container().begin() + insertIdx, item(form));
+                    arr->u_container().insert(arr->u_container().begin() + insertIdx, item{ make_weak_form_id(form, context) });
                     return false;
                 }
 
                 array *arr;
                 uint32_t insertIdx;
+                tes_context& context;
 
-                inserter(array *obj, uint32_t insertAt) : arr(obj), insertIdx(insertAt) {}
+                inserter(array *obj, uint32_t insertAt, tes_context& c) : arr(obj), insertIdx(insertAt), context(c) {}
             };
 
             doWriteOp(obj, insertAtIndex, [formList, &obj](uint32_t idx) {
-                formList->Visit(inserter(obj, idx));
+                formList->Visit(inserter{ obj, idx, tes_context::instance() });
             });
         }
         REGISTERF2(addFromFormList, "* source insertAtIndex=-1", nullptr);
 
         template<class T>
-        static T itemAtIndex(ref obj, Index index, T t = T(0)) {
+        static T itemAtIndex(ref obj, Index index, T t = default_value<T>()) {
             doReadOp(obj, index, [=, &t](uint32_t idx) {
                 t = obj->_array[idx].readAs<T>();
             });
@@ -142,7 +145,7 @@ NEGATIVE_IDX_COMMENT);
         REGISTERF(itemAtIndex<Float32>, "getFlt", "* index default=0.0", "");
         REGISTERF(itemAtIndex<skse::string_ref>, "getStr", "* index default=\"\"", "");
         REGISTERF(itemAtIndex<object_base*>, "getObj", "* index default=0", "");
-        REGISTERF(itemAtIndex<TESForm*>, "getForm", "* index default=None", "");
+        REGISTERF(itemAtIndex<form_ref>, "getForm", "* index default=None", "");
 
         template<class T>
         static SInt32 findVal(ref obj, T value, SInt32 pySearchStartIndex = 0) {
@@ -169,7 +172,7 @@ NEGATIVE_IDX_COMMENT);
         REGISTERF(findVal<Float32>, "findFlt", "* value searchStartIndex=0", "");
         REGISTERF(findVal<const char *>, "findStr", "* value searchStartIndex=0", "");
         REGISTERF(findVal<object_base*>, "findObj", "* container searchStartIndex=0", "");
-        REGISTERF(findVal<TESForm*>, "findForm", "* value searchStartIndex=0", "");
+        REGISTERF(findVal<form_ref>, "findForm", "* value searchStartIndex=0", "");
 
         template<class T>
         static void replaceItemAtIndex(ref obj, Index index, T val) {
@@ -182,20 +185,20 @@ NEGATIVE_IDX_COMMENT);
         REGISTERF(replaceItemAtIndex<Float32>, "setFlt", "* index value", "");
         REGISTERF(replaceItemAtIndex<const char *>, "setStr", "* index value", "");
         REGISTERF(replaceItemAtIndex<object_base*>, "setObj", "* index container", "");
-        REGISTERF(replaceItemAtIndex<TESForm*>, "setForm", "* index value", "");
+        REGISTERF(replaceItemAtIndex<form_ref>, "setForm", "* index value", "");
 
         template<class T>
         static void addItemAt(ref obj, T val, SInt32 addToIndex = -1) {
             doWriteOp(obj, addToIndex, [&](uint32_t idx) {
-                obj->_array.insert(obj->begin() + idx, item(val));
+                (void)obj->_array.emplace(obj->begin() + idx, val);
             });
         }
         REGISTERF(addItemAt<SInt32>, "addInt", "* value addToIndex=-1", "appends value/container to the end of array.\n\
-if addToIndex >= 0 it inserts value at given index. "NEGATIVE_IDX_COMMENT);
+if addToIndex >= 0 it inserts value at given index. " NEGATIVE_IDX_COMMENT);
         REGISTERF(addItemAt<Float32>, "addFlt", "* value addToIndex=-1", "");
         REGISTERF(addItemAt<const char *>, "addStr", "* value addToIndex=-1", "");
         REGISTERF(addItemAt<object_base*>, "addObj", "* container addToIndex=-1", "");
-        REGISTERF(addItemAt<TESForm*>, "addForm", "* value addToIndex=-1", "");
+        REGISTERF(addItemAt<form_ref>, "addForm", "* value addToIndex=-1", "");
 
         static Index count(ref obj) {
             return tes_object::count(obj);
@@ -214,6 +217,22 @@ if addToIndex >= 0 it inserts value at given index. "NEGATIVE_IDX_COMMENT);
         }
         REGISTERF2(eraseIndex, "* index", "erases item at index. "NEGATIVE_IDX_COMMENT);
 
+        static void eraseRange(ref obj, SInt32 first, SInt32 last) {
+
+            // 0,1,2,3,4
+            // b        e
+            // -1 is 4th index
+            // begin + 4 is last, valid iterator
+            SInt32 pyIndexes[] { first, last };
+            doReadOp(obj, pyIndexes, [=](const std::array<uint32_t, 2>& indices) {
+                if (indices[0] <= indices[1]) {
+                    obj->_array.erase(obj->begin() + indices[0], obj->begin() + indices[1] + 1);
+                }
+            });
+        }
+        REGISTERF2(eraseRange, "* first last", "erases [first, last] range of items. "NEGATIVE_IDX_COMMENT
+            "\nFor ex. with [1,-1] range it will erase everything except the first item");
+
         static SInt32 valueType(ref obj, SInt32 index) {
             SInt32 type = item_type::no_item;
             doReadOp(obj, index, [=, &type](uint32_t idx) {
@@ -243,7 +262,7 @@ if addToIndex >= 0 it inserts value at given index. "NEGATIVE_IDX_COMMENT);
             }
             return obj;
         }
-        REGISTERF2(sort, "*", "Sorts the items into ascending order (none < int < float < object < form < string). Returns array itself");
+        REGISTERF2(sort, "*", "Sorts the items into ascending order (none < int < float < form < object < string). Returns the array itself");
 
         static ref unique(ref obj) {
             if (obj) {
@@ -256,6 +275,56 @@ if addToIndex >= 0 it inserts value at given index. "NEGATIVE_IDX_COMMENT);
         }
         REGISTERF2(unique, "*", "Sorts the items, removes duplicates. Returns array itself. You can treat it as JSet now");
 
+        template<
+            typename ValueType,
+            typename PArrayType = VMArray<ValueType>
+        >
+        static bool writeToPapyrusArray(
+                ref obj
+                , PArrayType targetArray
+                , SInt32 py_writeAtIdx = 0         // start write at index of @targetArray
+                , SInt32 py_stopWriteAtIdx = -1    // stop writing at this last index of @targetArray
+                , SInt32 py_readIdx = 0
+                , ValueType defaultRead = default_value<ValueType>()
+            )
+        {
+            if (!obj) {
+                return false;
+            }
+
+            const auto targetLength = targetArray.Length();
+            const auto fstIdx = convertReadIndex(targetLength, py_writeAtIdx);
+            const auto lstIdx = convertReadIndex(targetLength, py_stopWriteAtIdx);
+
+            if (!(fstIdx && lstIdx && *fstIdx <= *lstIdx)) {
+                return false;
+            }
+
+            object_lock l(obj);
+            const auto readIdx = convertReadIndex(obj, py_readIdx);
+            const int32_t countToRead = *lstIdx - *fstIdx + 1;
+
+            if (!(readIdx && (*readIdx + countToRead - 1) < obj->u_count())) {
+                return false;
+            }
+
+            for (int32_t i = 0; i < countToRead; ++i) {
+                ValueType value = (*obj)[i + *readIdx].readAs<ValueType>();
+                targetArray.Set(&value, i + *fstIdx);
+            }
+
+            return true;
+        }
+
+#define ARGNAMES "* targetArray writeAtIdx=0 stopWriteAtIdx=-1 readIdx=0 defaultRead="
+        REGISTERF(writeToPapyrusArray<SInt32>, "writeToIntegerPArray", ARGNAMES "0", "TOTOTO??");
+        REGISTERF(writeToPapyrusArray<Float32>, "writeToFloatPArray", ARGNAMES "0.0", "");
+        REGISTERF(writeToPapyrusArray<TESForm*>, "writeToFormPArray", ARGNAMES "None", "");
+        //REGISTERF(writeToPapyrusArray<bool>, "writeToBooleanPArray", ARGNAMES, "");
+        REGISTERF(writeToPapyrusArray<skse::string_ref>, "writeToStringPArray", ARGNAMES "\"\"", "");
+
+#undef ARGNAMES
+
     };
 
     TES_META_INFO(tes_array);
diff --git a/JContainers/src/api_3/tes_db.h b/JContainers/src/api_3/tes_db.h
index 66ba1b7..cd27c3d 100644
--- a/JContainers/src/api_3/tes_db.h
+++ b/JContainers/src/api_3/tes_db.h
@@ -10,12 +10,12 @@ namespace tes_api_3 {
         void additionalSetup() {
             metaInfo.comment =
 "Global entry point to store mod information. Main intent - replace global variables\n\
-Manages keys and values associations as JMap";
+Manages keys and values associations (like JMap)";
         }
 
         template<class T>
-        static T solveGetter(const char* path, T t = T(0)) {
-            return tes_object::resolveGetter<T>(tes_context::instance().database(), path, t); 
+        static T solveGetter(const char* path, T t= default_value<T>()) {
+            return tes_object::resolveGetter<T>(&tes_context::instance().root(), path, t); 
         }
         REGISTERF(solveGetter<Float32>, "solveFlt", "path default=0.0",
 "attempts to get value associated with path.\n\
@@ -32,11 +32,11 @@ JDB.solveObj(\".frostfall.arrayC\") will return array containing [\"stringValue\
         REGISTERF(solveGetter<SInt32>, "solveInt", "path default=0", nullptr);
         REGISTERF(solveGetter<skse::string_ref>, "solveStr", "path default=\"\"", nullptr);
         REGISTERF(solveGetter<object_base*>, "solveObj", "path default=0", nullptr);
-        REGISTERF(solveGetter<TESForm*>, "solveForm", "path default=None", nullptr);
+        REGISTERF(solveGetter<form_ref>, "solveForm", "path default=None", nullptr);
 
         template<class T>
         static bool solveSetter(const char* path, T value, bool createMissingKeys = false) { 
-            return tes_object::solveSetter(tes_context::instance().database(), path, value, createMissingKeys);
+            return tes_object::solveSetter(&tes_context::instance().root(), path, value, createMissingKeys);
         }
         REGISTERF(solveSetter<Float32>, "solveFltSetter", "path value createMissingKeys=false",
             "Attempts to assign value. Returns false if no such path\n"
@@ -44,20 +44,16 @@ JDB.solveObj(\".frostfall.arrayC\") will return array containing [\"stringValue\
         REGISTERF(solveSetter<SInt32>, "solveIntSetter", "path value createMissingKeys=false", nullptr);
         REGISTERF(solveSetter<const char*>, "solveStrSetter", "path value createMissingKeys=false", nullptr);
         REGISTERF(solveSetter<object_base*>, "solveObjSetter", "path value createMissingKeys=false", nullptr);
-        REGISTERF(solveSetter<TESForm*>, "solveFormSetter", "path value createMissingKeys=false", nullptr);
+        REGISTERF(solveSetter<form_ref>, "solveFormSetter", "path value createMissingKeys=false", nullptr);
 
 
         static void setObj(const char *path, object_stack_ref& obj) {
-            map *dbMap = tes_context::instance().database();
-
-            if (!dbMap) {
-                return;
-            }
+            map& dbMap = tes_context::instance().root();
 
             if (obj) {
-                tes_map::setItem(dbMap, path, obj);
+                tes_map::setItem(&dbMap, path, obj);
             } else {
-                tes_map::removeKey(dbMap, path);
+                tes_map::removeKey(&dbMap, path);
             }
         }
         REGISTERF(setObj, "setObj", "key object",
@@ -67,29 +63,29 @@ for ex. JDB.setObj(\"frostfall\", frostFallInformation) will associate 'frostall
 );
 
         static bool hasPath(const char* path) {
-            return tes_object::hasPath(tes_context::instance().database(), path);
+            return tes_object::hasPath(&tes_context::instance().root(), path);
         }
         REGISTERF2(hasPath, "path", "returns true, if DB capable resolve given path, e.g. it able to execute solve* or solver*Setter functions successfully");
 
         static object_base* allKeys() {
-            return tes_map::allKeys( tes_context::instance().database()->as<map>() );
+            return tes_map::allKeys( &tes_context::instance().root() );
         }
         REGISTERF2(allKeys, "*", "returns new array containing all JDB keys");
 
         static object_base* allValues() {
-            return tes_map::allValues( tes_context::instance().database()->as<map>() );
+            return tes_map::allValues( &tes_context::instance().root() );
         }
         REGISTERF2(allValues, "*", "returns new array containing all containers associated with JDB");
 
         static void writeToFile(const char * path) {
-            tes_object::writeToFile( tes_context::instance().database(), path);
+            tes_object::writeToFile( &tes_context::instance().root(), path);
         }
         REGISTERF2(writeToFile, "path", "writes storage data into JSON file at given path");
 
         static void readFromFile(const char *path) {
         }
         REGISTERF2(readFromFile, "path",
-"DEPRECATE. Reads information from a file at given path and fills storage with it's JSON content");
+"DEPRECATED. Reads information from a JSON file at given path and replaces JDB content with the file content");
 
     };
 
diff --git a/JContainers/src/api_3/tes_form_db.h b/JContainers/src/api_3/tes_form_db.h
index a0b9b1b..e2cde8e 100644
--- a/JContainers/src/api_3/tes_form_db.h
+++ b/JContainers/src/api_3/tes_form_db.h
@@ -46,7 +46,7 @@ namespace tes_api_3 {
                 auto pair2 = bs::half_split_if(pair1.second, bs::is_any_of(".["));
 
                 if (!pair2.first.empty() && !pair2.second.empty()) {
-                    auto strorageNameLen = (std::min)(bytesCount-1,  pair2.first.size());
+                    auto strorageNameLen = std::min<size_t>(bytesCount-1,  pair2.first.size());
                     std::copy_n(pair2.first.begin(), strorageNameLen, _storageName);
                     _storageName[strorageNameLen] = '\0';
 
@@ -64,13 +64,15 @@ namespace tes_api_3 {
             }
         };
 
+        using key_cref = const form_ref_lightweight&;
+
         static form_map *makeFormStorage(const char *storageName) {
             if (!validate_storage_name(storageName)) {
                 return nullptr;
             }
 
-            auto db = tes_context::instance().database();
-            form_map::ref fmap = tes_map::getItem<object_base*>(db, storageName)->as<form_map>();
+            auto& db = tes_context::instance().root();
+            form_map::ref fmap = tes_map::getItem<object_base*>(&db, storageName)->as<form_map>();
 
             if (!fmap) {
                 fmap = tes_object::object<form_map>();
@@ -84,7 +86,7 @@ namespace tes_api_3 {
             return name && *name;
         }
 
-        static void setEntry(const char *storageName, FormId formKey, object_stack_ref& entry) {
+        static void setEntry(const char *storageName, key_cref formKey, object_stack_ref& entry) {
             if (!validate_storage_name(storageName) || !formKey) {
                 return;
             }
@@ -93,14 +95,14 @@ namespace tes_api_3 {
                 auto fmap = makeFormStorage(storageName);
                 tes_form_map::setItem(fmap, formKey, entry);
             } else {
-                auto db = tes_context::instance().database();
-                auto fmap = tes_map::getItem<object_base*>(db, storageName)->as<form_map>();
+                auto& db = tes_context::instance().root();
+                auto fmap = tes_map::getItem<object_base*>(&db, storageName)->as<form_map>();
                 tes_form_map::removeKey(fmap, formKey);
             }
         }
         REGISTERF2(setEntry, "storageName fKey entry", "associates given form key and entry (container). set entry to zero to destroy association");
 
-        static map *makeMapEntry(const char *storageName, FormId form) {
+        static map *makeMapEntry(const char *storageName, key_cref form) {
             if (!form || !validate_storage_name(storageName)) {
                 return nullptr;
             }
@@ -116,21 +118,21 @@ namespace tes_api_3 {
         }
         REGISTERF(makeMapEntry, "makeEntry", "storageName fKey", "returns (or creates new if not found) JMap entry for given storage and form");
 
-        static object_base *findEntry(const char *storageName, FormId form) {
-            auto db = tes_context::instance().database();
-            form_map *fmap = tes_map::getItem<object_base*>(db, storageName)->as<form_map>();
+        static object_base *findEntry(const char *storageName, key_cref form) {
+            auto& db = tes_context::instance().root();
+            form_map *fmap = tes_map::getItem<object_base*>(&db, storageName)->as<form_map>();
             return tes_form_map::getItem<object_base*>(fmap, form);
         }
         REGISTERF2(findEntry, "storageName fKey", "search for entry for given storage and form");
 
-        static map *findMapEntry(const char *storageName, FormId form) {
+        static map *findMapEntry(const char *storageName, key_cref form) {
             return findEntry(storageName, form)->as<map>();
         }
 
         //////////////////////////////////////////////////////////////////////////
 
         template<class T>
-        static T solveGetter(FormId form, const char* path, T t = T(0)) {
+        static T solveGetter(key_cref form, const char* path, T t= default_value<T>()) {
             subpath_extractor sub(path, is_path);
             return tes_object::resolveGetter<T>(findEntry(sub.storageName(), form), sub.rest(), t); 
         }
@@ -138,10 +140,10 @@ namespace tes_api_3 {
         REGISTERF(solveGetter<SInt32>, "solveInt", "fKey path default=0", nullptr);
         REGISTERF(solveGetter<skse::string_ref>, "solveStr", "fKey path default=\"\"", nullptr);
         REGISTERF(solveGetter<Handle>, "solveObj", "fKey path default=0", nullptr);
-        REGISTERF(solveGetter<TESForm*>, "solveForm", "fKey path default=None", nullptr);
+        REGISTERF(solveGetter<form_ref>, "solveForm", "fKey path default=None", nullptr);
 
         template<class T>
-        static bool solveSetter(FormId form, const char* path, T value, bool createMissingKeys = false) {
+        static bool solveSetter(key_cref form, const char* path, T value, bool createMissingKeys = false) {
             subpath_extractor sub(path, is_path);
             return tes_object::solveSetter(findEntry(sub.storageName(), form), sub.rest(), value, createMissingKeys);
         }
@@ -151,9 +153,9 @@ namespace tes_api_3 {
         REGISTERF(solveSetter<SInt32>, "solveIntSetter", "fKey path value createMissingKeys=false", nullptr);
         REGISTERF(solveSetter<const char*>, "solveStrSetter", "fKey path value createMissingKeys=false", nullptr);
         REGISTERF(solveSetter<object_stack_ref&>, "solveObjSetter", "fKey path value createMissingKeys=false", nullptr);
-        REGISTERF(solveSetter<TESForm*>, "solveFormSetter", "fKey path value createMissingKeys=false", nullptr);
+        REGISTERF(solveSetter<form_ref>, "solveFormSetter", "fKey path value createMissingKeys=false", nullptr);
 
-        static bool hasPath(FormId form, const char* path) {
+        static bool hasPath(key_cref form, const char* path) {
             subpath_extractor sub(path);
             return tes_object::hasPath(findMapEntry(sub.storageName(), form), sub.rest());
         }
@@ -161,7 +163,7 @@ namespace tes_api_3 {
 
         //////////////////////////////////////////////////////////////////////////
 
-        static object_base* allKeys(FormId form, const char *path) {
+        static object_base* allKeys(key_cref form, const char *path) {
             subpath_extractor sub(path);
             return tes_map::allKeys( findMapEntry(sub.storageName(), form) );
         }
@@ -170,14 +172,14 @@ namespace tes_api_3 {
             "\n"
             "returns new array containing all keys");
 
-        static object_base* allValues(FormId form, const char *path) {
+        static object_base* allValues(key_cref form, const char *path) {
             subpath_extractor sub(path);
             return tes_map::allValues( findMapEntry(sub.storageName(), form) );
         }
         REGISTERF2(allValues, "fKey key", "returns new array containing all values");
 
         template<class T>
-        static T getItem(FormId form, const char* path) {
+        static T getItem(key_cref form, const char* path) {
             subpath_extractor sub(path);
             return tes_map::getItem<T>( findMapEntry(sub.storageName(), form), sub.rest());
         }
@@ -186,10 +188,10 @@ namespace tes_api_3 {
         REGISTERF(getItem<Float32>, "getFlt", "fKey key", "");
         REGISTERF(getItem<skse::string_ref>, "getStr", "fKey key", "");
         REGISTERF(getItem<object_base *>, "getObj", "fKey key", "");
-        REGISTERF(getItem<TESForm*>, "getForm", "fKey key", "");
+        REGISTERF(getItem<form_ref>, "getForm", "fKey key", "");
 
         template<class T>
-        static void setItem(FormId form, const char* path, T item) {
+        static void setItem(key_cref form, const char* path, T item) {
             subpath_extractor sub(path);
             tes_map::setItem( makeMapEntry(sub.storageName(), form), sub.rest(), item);
         }
@@ -197,7 +199,7 @@ namespace tes_api_3 {
         REGISTERF(setItem<Float32>, "setFlt", "fKey key value", "");
         REGISTERF(setItem<const char *>, "setStr", "fKey key value", "");
         REGISTERF(setItem<object_stack_ref&>, "setObj", "fKey key container", "");
-        REGISTERF(setItem<TESForm*>, "setForm", "fKey key value", "");
+        REGISTERF(setItem<form_ref>, "setForm", "fKey key value", "");
     };
 
     TES_META_INFO(tes_form_db);
@@ -235,9 +237,9 @@ namespace tes_api_3 {
 
         auto formStorage = tes_form_db::makeFormStorage(storageName);
         EXPECT_NOT_NIL(formStorage);
-        EXPECT_EQ( formStorage, tes_form_db::makeFormStorage(storageName));
+        EXPECT_EQ(formStorage, tes_form_db::makeFormStorage(storageName));
 
-        FormId fakeForm = (FormId)0x14;
+        auto fakeForm = make_lightweight_form_ref((FormId)0x14, tes_context::instance());
 
         auto entry = tes_form_db::makeMapEntry(storageName, fakeForm);
         EXPECT_NOT_NIL(entry);
@@ -247,7 +249,7 @@ namespace tes_api_3 {
 
     TEST(tes_form_db, get_set)
     {
-        FormId fakeForm = (FormId)0x14;
+        auto fakeForm = make_lightweight_form_ref((FormId)0x14, tes_context::instance());
 
         const char *path = ".forms.object";
 
diff --git a/JContainers/src/api_3/tes_lua.h b/JContainers/src/api_3/tes_lua.h
index ec8a42e..9302eb3 100644
--- a/JContainers/src/api_3/tes_lua.h
+++ b/JContainers/src/api_3/tes_lua.h
@@ -1,17 +1,78 @@
-namespace collections {
-#if 0
+
+namespace tes_api_3 {
+
+    using namespace collections;
+
+#if 1
     class tes_lua : public class_meta < tes_lua > {
     public:
 
         void additionalSetup() {
-            metaInfo.comment = "executes lua code";
+            metaInfo.comment = "Evaluates Lua code";
         }
 
-        REGISTER_TES_NAME("JLua");
+#define ARGNAMES "luaCode transport default="
+#define ARGNAMES_2 " minimizeLifetime=true"
+        REGISTERF(evalLua<Float32>, "evalLuaFlt", ARGNAMES "0.0" ARGNAMES_2,
+R"===(Evaluates piece of Lua code. The arguments are carried by @transport object.
+The @transport is any kind of object, not just JMap.
+If @minimizeLifetime is True the function will invoke JValue.zeroLifetime on the @transport object.
+Returns @default value if evaluation fails.
+Usage example:
+
+    ; 7 from the end until 9 from the end. Returns "Lua" string
+    string input = "Hello Lua user"
+    string s = JLua.evaLuaStr("return string.sub(args.string, args.low, args.high)",\
+        JLua.setObj("string",input, JLua.setInt("low",7, JLua.setInt("high",9 )))\
+    )
+)===");
+        REGISTERF(evalLua<SInt32>, "evalLuaInt", ARGNAMES "0" ARGNAMES_2, nullptr);
+        REGISTERF(evalLua<skse::string_ref>, "evalLuaStr", ARGNAMES R"("")" ARGNAMES_2, nullptr);
+        REGISTERF(evalLua<Handle>, "evalLuaObj", ARGNAMES "0" ARGNAMES_2, nullptr);
+        REGISTERF(evalLua<TESForm*>, "evalLuaForm", ARGNAMES "None" ARGNAMES_2, nullptr);
+#undef ARGNAMES
+#undef ARGNAMES_2
+
+        template<class ResultType>
+        static ResultType evalLua(const char* luaCode, object_base* transport, ResultType def, bool minimizeLifetime = true) {
+            auto result = lua::eval_lua_function(tes_context::instance(), transport, luaCode);
+            if (transport && minimizeLifetime) {
+                transport->zero_lifetime();
+            }
+            return result ? result->readAs<ResultType>() : def;
+        }
+
+#define ARGNAMES "key value transport=0"
+        REGISTERF(pushArg<const char*>, "setStr", ARGNAMES,
+R"===(Inserts new (or replaces existing) {key -> value} pair. Expects that @transport is JMap object, if @transport is 0 it creates new JMap object.
+Returns @transport)===");
+        REGISTERF(pushArg<Float32>, "setFlt", ARGNAMES, "");
+        REGISTERF(pushArg<SInt32>, "setInt", ARGNAMES, "");
+        REGISTERF(pushArg<form_ref>, "setForm", ARGNAMES, "");
+        REGISTERF(pushArg<object_base*>, "setObj", ARGNAMES, "");
+#undef ARGNAMES
+
+        template<class ArgType>
+        static map* pushArg(const char* key, ArgType arg, map* transport = nullptr) {
+            if (!transport) {
+                transport = &map::object(tes_context::instance());
+            }
 
+            tes_map::setItem<ArgType>(transport, key, arg);
+            return transport;
+        }
 
+        REGISTER_TES_NAME("JLua");
     };
 
+    TEST(JLua, simple)
+    {
+        EXPECT_EQ( 8, tes_lua::evalLua<float>("return args.x * args.y", tes_lua::pushArg("x", 2, tes_lua::pushArg("y", 4)), 0.f) );
+
+        EXPECT_EQ(1, tes_lua::evalLua<SInt32>("return jobject ~= nil", tes_lua::pushArg("garbage", 4), -1))
+            << "@jobject (@args alias) isn't supported";
+    }
     TES_META_INFO(tes_lua);
 #endif
 }
+ 
\ No newline at end of file
diff --git a/JContainers/src/api_3/tes_map.h b/JContainers/src/api_3/tes_map.h
index 24b0105..689f175 100644
--- a/JContainers/src/api_3/tes_map.h
+++ b/JContainers/src/api_3/tes_map.h
@@ -3,11 +3,18 @@ namespace tes_api_3 {
     using namespace collections;
 
 
-    template<class Key, class Cnt>
-    class tes_map_t : public class_meta< tes_map_t<Key, Cnt> > {
+    template<class Key
+        , class Cnt
+        , class key_ref = Key &
+        , class key_cref = const key_ref
+    >
+    class tes_map_t : public class_meta< tes_map_t<Key, Cnt, key_ref, key_cref> > {
     public:
 
         using map_functions = map_functions_templ < Cnt >;
+        using map_type = Cnt;
+        using tes_key = reflection::binding::get_converter_tes_type<typename map_type::key_type>;
+
         typedef typename Cnt* ref;
 
         tes_map_t() {
@@ -18,7 +25,7 @@ namespace tes_api_3 {
         REGISTERF(tes_object::object<Cnt>, "object", "", kCommentObject);
 
         template<class T>
-        static T getItem(Cnt *obj, Key key, T def = T(0)) {
+        static T getItem(Cnt *obj, key_cref key, T def = default_value<T>()) {
             map_functions::doReadOp(obj, key, [&](item& itm) { def = itm.readAs<T>(); });
             return def;
         }
@@ -26,24 +33,24 @@ namespace tes_api_3 {
         REGISTERF(getItem<Float32>, "getFlt", "object key default=0.0", "");
         REGISTERF(getItem<skse::string_ref>, "getStr", "object key default=\"\"", "");
         REGISTERF(getItem<object_base*>, "getObj", "object key default=0", "");
-        REGISTERF(getItem<TESForm*>, "getForm", "object key default=None", "");
+        REGISTERF(getItem<form_ref>, "getForm", "object key default=None", "");
 
         template<class T>
-        static void setItem(Cnt *obj, Key key, T val) {
+        static void setItem(Cnt *obj, key_cref key, T val) {
             map_functions::doWriteOp(obj, key, [&](item& itm) { itm = val; });
         }
         REGISTERF(setItem<SInt32>, "setInt", "* key value", "creates key-value association. replaces existing value if any");
         REGISTERF(setItem<Float32>, "setFlt", "* key value", "");
         REGISTERF(setItem<const char *>, "setStr", "* key value", "");
         REGISTERF(setItem<object_base*>, "setObj", "* key container", "");
-        REGISTERF(setItem<TESForm*>, "setForm", "* key value", "");
+        REGISTERF(setItem<form_ref>, "setForm", "* key value", "");
 
-        static bool hasKey(ref obj, Key key) {
+        static bool hasKey(ref obj, key_cref key) {
             return valueType(obj, key) != 0;
         }
         REGISTERF2(hasKey, "* key", "returns true, if something associated with key");
 
-        static SInt32 valueType(ref obj, Key key) {
+        static SInt32 valueType(ref obj, key_cref key) {
             auto type = item_type::no_item;
             map_functions::doReadOp(obj, key, [&](item& itm) { type = itm.type(); });
             return (SInt32)type;
@@ -60,13 +67,32 @@ namespace tes_api_3 {
 
                 arr._array.reserve(obj->u_count());
                 for each(auto& pair in obj->u_container()) {
-                    arr.u_container().push_back(item(pair.first));
+                    arr.u_container().emplace_back(pair.first);
                 }
             },
                 tes_context::instance());
         }
         REGISTERF(allKeys, "allKeys", "*", "returns new array containing all keys");
 
+        static VMResultArray<tes_key> allKeysPArray(Cnt* obj) {
+            if (!obj) {
+                return VMResultArray<tes_key>();
+            }
+
+            VMResultArray<tes_key> keys;
+            object_lock l(obj);
+            keys.reserve(obj->u_count());
+            std::transform(obj->u_container().begin(), obj->u_container().end(),
+                std::back_inserter(keys),
+                [](const typename map_type::value_type& p) {
+                    return reflection::binding::get_converter<typename map_type::key_type>::convert2Tes(p.first);
+                }
+            );
+
+            return keys;
+        }
+        REGISTERF2(allKeysPArray, "*", "");
+
         static object_base* allValues(Cnt *obj) {
             if (!obj) {
                 return nullptr;
@@ -84,8 +110,8 @@ namespace tes_api_3 {
         }
         REGISTERF(allValues, "allValues", "*", "returns new array containing all values");
 
-        static bool removeKey(Cnt *obj, Key key) {
-            if (obj && map_key_checker::check(key)) {
+        static bool removeKey(Cnt *obj, key_cref key) {
+            if (obj) {
                 return obj->erase(key);
             }
             return false;
@@ -133,9 +159,8 @@ namespace tes_api_3 {
 
         //////////////////////////////////////////////////////////////////////////
 
-        static Key nextKey(ref obj, Key previousKey, Key endKey) {
-            map_functions::nextKey(obj, previousKey, [&](const typename Cnt::key_type & key) { endKey = key; });
-            return endKey;
+        static Key nextKey(ref obj, key_cref previousKey, key_ref endKey) {
+            return map_functions::nextKey_forPapyrus(obj, previousKey, endKey);
         }
 
         static Key getNthKey(ref obj, SInt32 keyIndex) {
@@ -145,9 +170,9 @@ namespace tes_api_3 {
         }
     };
 
-    typedef tes_map_t<const char*, map > tes_map;
-    typedef tes_map_t<FormId, form_map> tes_form_map;
-    typedef tes_map_t<SInt32, integer_map> tes_integer_map;
+    typedef tes_map_t<const char*, map, const char*, const char*> tes_map;
+    typedef tes_map_t<form_ref_lightweight, form_map, form_ref_lightweight, form_ref_lightweight> tes_form_map;
+    typedef tes_map_t<int32_t, integer_map, int32_t, int32_t> tes_integer_map;
 
     void tes_map::additionalSetup() {
         metaInfo._className = "JMap";
@@ -168,12 +193,20 @@ namespace tes_api_3 {
     //////////////////////////////////////////////////////////////////////////
 
     const char *tes_map_nextKey_comment =
-        "Simplifies iteration over container's contents.\nIncrements and returns previous key, pass defaulf parameter to begin iteration. Usage:\n"
-        "string key = JMap.nextKey(map)\n"
-        "while key\n"
-        "  <retrieve values here>\n"
-        "  key = JMap.nextKey(map, key)\n"
-        "endwhile";
+R"===(Simplifies iteration over container's contents.
+Increments and returns previous key, pass default parameters to begin iteration.
+If @previousKey == @endKey the function returns first key.
+The function returns so-called 'valid' keys (the ones != @endKey).
+The function returns @endKey - so-called 'invalid' key to signal that iteration has reached its end.
+
+Usage:
+
+    string key = JMap.nextKey(map, previousKey="", endKey="")
+    while key != ""
+      <retrieve values here>
+      key = JMap.nextKey(map, key, endKey="")
+    endwhile
+)===";
 
     struct tes_map_ext : class_meta < tes_map_ext > {
         REGISTER_TES_NAME("JMap");
@@ -198,8 +231,24 @@ namespace tes_api_3 {
 
     struct tes_form_map_ext : class_meta < tes_form_map_ext > {
         REGISTER_TES_NAME("JFormMap");
-        REGISTERF(tes_form_map::nextKey, "nextKey", STR(* previousKey=None endKey=None), tes_map_nextKey_comment);
+        REGISTERF(tes_form_map_ext::nextKey, "nextKey", STR(* previousKey=None endKey=None), tes_map_nextKey_comment);
         REGISTERF(tes_form_map::getNthKey, "getNthKey", "* keyIndex", tes_map_ext::getNthKey_comment());
+
+        static form_ref_lightweight nextKey(form_map* obj
+            , const form_ref_lightweight& previousKey
+            , const form_ref_lightweight& endKey)
+        {
+            struct KeyCompare {
+                bool operator()(const form_ref& nKey, const form_ref_lightweight& endKey) const {
+                    return nKey == endKey
+                        && skse::lookup_form(nKey.get()) == skse::lookup_form(endKey.get());
+                }
+            };
+
+            // @KeyCompare predicate customizes n@extKey_forPapyrus function
+            // so that the function will not return unloaded (None) form keys at Papyrus level
+            return map_functions_templ < form_map >::nextKey_forPapyrus(obj, previousKey, endKey, KeyCompare{});
+        }
     };
 
     struct tes_integer_map_ext : class_meta < tes_integer_map_ext > {
diff --git a/JContainers/src/api_3/tes_object.h b/JContainers/src/api_3/tes_object.h
index f743617..36827fe 100644
--- a/JContainers/src/api_3/tes_object.h
+++ b/JContainers/src/api_3/tes_object.h
@@ -1,12 +1,11 @@
 
-#include "lua_module.h"
+#include "collections/lua_module.h"
 
 namespace tes_api_3 {
 
     using namespace collections;
 
-    const char *kCommentObject = "creates new container object. returns container identifier (integer number).\n"
-        "identifier is the thing you will have to pass to the most of container's functions as a first argument";
+    const char *kCommentObject = "creates new container object. returns container's identifier (unique integer number).";
 
 #define VALUE_TYPE_COMMENT "0 - no value, 1 - none, 2 - int, 3 - float, 4 - form, 5 - object, 6 - string"
 
@@ -18,7 +17,7 @@ namespace tes_api_3 {
         REGISTER_TES_NAME("JValue");
 
         void additionalSetup() {
-            metaInfo.comment = "Each container (JArray, JMap & JFormMap) inherits JValue functionality";
+            metaInfo.comment = "Common functionality, shared by JArray, JMap, JFormMap, JIntMap";
         }
 
         static object_base* retain(ref obj, const char* tag = nullptr) {
@@ -34,7 +33,7 @@ namespace tes_api_3 {
 R"===(--- Lifetime management functionality.
 Read this https://github.com/SilverIce/JContainers/wiki/Lifetime-Management before using any of lifetime management functions
 
-Retains and returns the object. Purpose - extend object lifetime)==="
+Retains and returns the object.)==="
             );
 
         template<class T>
@@ -81,9 +80,8 @@ Retains and returns the object. Purpose - extend object lifetime)==="
             }
         }
         REGISTERF2(releaseObjectsWithTag, "tag",
-"For cleanup purpose only - releases lost (and not lost) objects with given tag.\n"
-"Complements all retain calls objects with given tag received with release calls.\n"
-"See 'object lifetime management' section for more information");
+"For cleanup purpose only - releases all objects with given tag.\n"
+"Complements all retain calls the objects with given tag received with release calls.");
 
         static ref zeroLifetime(ref obj) {
             if (obj) {
@@ -91,8 +89,8 @@ Retains and returns the object. Purpose - extend object lifetime)==="
             }
             return obj;
         }
-        REGISTERF2(zeroLifetime, "*", "Reduces the time JC temporarily owns the object to a minimal value, returns the object.\n\
-By using this function a user helps JC to get rid of no-more-needed to the user object as soon as possible (ofc. the object won't be deleted if something retains or contains it)");
+        REGISTERF2(zeroLifetime, "*", "Minimizes the time JC temporarily owns the object, returns the object.\n\
+By using this function you help JC to delete unused object as soon as possible (the object won't be deleted if something retains or contains it)");
 
 #       define JC_OBJECT_POOL_KEY   "__tempPools"
 
@@ -103,7 +101,7 @@ By using this function a user helps JC to get rid of no-more-needed to the user
 
                 array::ref location;
 
-                ca::visit_value(*tes_context::instance().database(), path.c_str(), ca::creative, [&](item& value) {
+                ca::visit_value(tes_context::instance().root(), path.c_str(), ca::creative, [&](item& value) {
                     if (auto loc = value.object()->as<array>()) {
                         location = loc;
                     }
@@ -113,20 +111,6 @@ By using this function a user helps JC to get rid of no-more-needed to the user
                     }
                 });
 
-/*
-                path_resolving::resolve(tes_context::instance(), tes_context::instance().database(), path.c_str(), [&](item* itmPtr) {
-                    if (itmPtr) {
-                        if (auto loc = itmPtr->object()->as<array>()) {
-                            location = loc;
-                        }
-                        else {
-                            location = &array::object(tes_context::instance());
-                            *itmPtr = location.get();
-                        }
-                    }
-                },
-                    true);*/
-
                 if (location) {
                     location->push(item(obj));
                 }
@@ -144,7 +128,7 @@ JValue.cleanPool(\"uniquePoolName\")"
 
         static void cleanPool(const char *poolName) {
             if (poolName) {
-                auto locationsMap = tes_context::instance().database()->findOrDef(JC_OBJECT_POOL_KEY).object()->as<map>();
+                auto locationsMap = tes_context::instance().root().findOrDef(JC_OBJECT_POOL_KEY).object()->as<map>();
                 if (locationsMap) {
                     locationsMap->erase(poolName);
                 }
@@ -153,19 +137,19 @@ JValue.cleanPool(\"uniquePoolName\")"
         REGISTERF2(cleanPool, "poolName", nullptr);
 
         static ref shallowCopy(ref obj) {
-            return obj ? &deep_copying::shallow_copy(tes_context::instance(), *obj) : nullptr;
+            return obj ? &copying::shallow_copy(tes_context::instance(), *obj) : nullptr;
         }
-        REGISTERF2(shallowCopy, "*", "--- Mics. functionality\n\nReturns shallow copy (doesn't copy child objects)");
+        REGISTERF2(shallowCopy, "*", "--- Mics. functionality\n\nReturns shallow copy (won't copy child objects)");
 
         static ref deepCopy(ref obj) {
-            return obj ? &deep_copying::deep_copy(tes_context::instance(), *obj) : nullptr;
+            return obj ? &copying::deep_copy(tes_context::instance(), *obj) : nullptr;
         }
         REGISTERF2(deepCopy, "*", "Returns deep copy");
 
         static bool isExists(ref obj) {
             return obj != nullptr;
         }
-        REGISTERF2(isExists, "*", "ntests whether given object identifier points to existing object");
+        REGISTERF2(isExists, "*", "Tests whether given object identifier points to existing object");
 
         template<class T> static bool isCast(ref obj) {
             return obj->as<T>() != nullptr;
@@ -184,7 +168,7 @@ JValue.cleanPool(\"uniquePoolName\")"
         static SInt32 count(ref obj) {
             return obj ? obj->s_count() : 0;
         }
-        REGISTERF2(count, "*", "returns the number of items in container");
+        REGISTERF2(count, "*", "returns amount of items in container");
 
         static void clear(ref obj) {
             if (obj) {
@@ -197,7 +181,7 @@ JValue.cleanPool(\"uniquePoolName\")"
             auto obj = json_deserializer::object_from_file(tes_context::instance(), path);
             return  obj;
         }
-        REGISTERF2(readFromFile, "filePath", "JSON serialization/deserialization:\n\ncreates and returns new container object containing the contents of JSON file");
+        REGISTERF2(readFromFile, "filePath", "JSON serialization/deserialization:\n\ncreates and returns new container object containing contents of JSON file");
 
         static object_base* readFromDirectory(const char *dirPath, const char *extension = "")
         {
@@ -232,8 +216,8 @@ JValue.cleanPool(\"uniquePoolName\")"
             return &files;
         }
         REGISTERF2(readFromDirectory, "directoryPath extension=\"\"",
-            "parses JSON files in directory (non recursive) and returns JMap containing {filename, container-object} pairs.\n"
-            "note: by default it does not filters files by extension and will try to parse everything");
+            "Parses JSON files in a directory (non recursive) and returns JMap containing {filename, container-object} pairs.\n"
+            "Note: by default it does not filter files by extension and will try to parse everything");
 
         static object_base* objectFromPrototype(const char *prototype) {
             auto obj = json_deserializer::object_from_json_data( tes_context::instance(), prototype);
@@ -278,14 +262,14 @@ JValue.cleanPool(\"uniquePoolName\")"
         }
         REGISTERF(hasPath, "hasPath", "* path",
 "Path resolving:\n\n\
-returns true, if container capable resolve given path.\n\
+returns true, if it's possible to resolve given path.\n\
 for ex. JValue.hasPath(container, \".player.health\") will check if given container has 'player' which has 'health' information"
                                       );
 
         REGISTERF(solvedValueType, "solvedValueType", "* path", "Returns type of resolved value. "VALUE_TYPE_COMMENT);
 
         template<class T>
-        static T resolveGetter(object_base *obj, const char* path, T val = T(0)) {
+        static T resolveGetter(object_base *obj, const char* path, T val = default_value<T>()) {
             if (!obj || !path)
                 return val;
 
@@ -301,7 +285,7 @@ for ex. JValue.hasPath(container, \".player.health\") will check if given contai
         REGISTERF(resolveGetter<SInt32>, "solveInt", "* path default=0", nullptr);
         REGISTERF(resolveGetter<skse::string_ref>, "solveStr", "* path default=\"\"", nullptr);
         REGISTERF(resolveGetter<Handle>, "solveObj", "* path default=0", nullptr);
-        REGISTERF(resolveGetter<TESForm*>, "solveForm", "* path default=None", nullptr);
+        REGISTERF(resolveGetter<form_ref>, "solveForm", "* path default=None", nullptr);
 
         template<class T>
         static bool solveSetter(object_base* obj, const char* path, T value, bool createMissingKeys = false) {
@@ -309,16 +293,6 @@ for ex. JValue.hasPath(container, \".player.health\") will check if given contai
                 return false;
 
             bool succeed = ca::assign(*obj, path, value, createMissingKeys ? ca::creative : ca::constant);
-/*
-            path_resolving::resolve(tes_context::instance(), obj, path, [&](item* itmPtr) {
-                if (itmPtr) {
-                    *itmPtr = item((T)value);
-                    succeed = true;
-                }
-            },
-                createMissingKeys);
-*/
-
             return succeed;
         }
         REGISTERF(solveSetter<Float32>, "solveFltSetter", "* path value createMissingKeys=false",
@@ -328,10 +302,10 @@ for ex. JValue.hasPath(container, \".player.health\") will check if given contai
         REGISTERF(solveSetter<SInt32>, "solveIntSetter", "* path value createMissingKeys=false", nullptr);
         REGISTERF(solveSetter<const char*>, "solveStrSetter", "* path value createMissingKeys=false", nullptr);
         REGISTERF(solveSetter<ref>, "solveObjSetter", "* path value createMissingKeys=false", nullptr);
-        REGISTERF(solveSetter<TESForm*>, "solveFormSetter", "* path value createMissingKeys=false", nullptr);
+        REGISTERF(solveSetter<form_ref>, "solveFormSetter", "* path value createMissingKeys=false", nullptr);
 
         template<class T>
-        static T evalLua(ref obj, const char* luaCode, T def = T(0)) {
+        static T evalLua(ref obj, const char* luaCode, T def = default_value<T>()) {
             auto result = lua::eval_lua_function(tes_context::instance(), obj, luaCode);
             return result ? result->readAs<T>() : def;
         }
@@ -339,7 +313,7 @@ for ex. JValue.hasPath(container, \".player.health\") will check if given contai
         REGISTERF(evalLua<SInt32>, "evalLuaInt", "* luaCode default=0", nullptr);
         REGISTERF(evalLua<skse::string_ref>, "evalLuaStr", "* luaCode default=\"\"", nullptr);
         REGISTERF(evalLua<Handle>, "evalLuaObj", "* luaCode default=0", nullptr);
-        REGISTERF(evalLua<TESForm*>, "evalLuaForm", "* luaCode default=None", nullptr);
+        REGISTERF(evalLua<form_ref>, "evalLuaForm", "* luaCode default=None", nullptr);
 
     };
 
diff --git a/JContainers/src/api_3/tes_string.h b/JContainers/src/api_3/tes_string.h
index 3f60441..11ba607 100644
--- a/JContainers/src/api_3/tes_string.h
+++ b/JContainers/src/api_3/tes_string.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include "util/util.h"
+#include "util/stl_ext.h"
 
 namespace collections {
 
@@ -35,6 +36,23 @@ namespace collections {
 Returns JArray object containing lines.\n\
 Accepts ASCII and UTF-8 encoded strings only");
 
+        static UInt32 decodeFormStringToFormId(const char* form_string) {
+            return util::to_integral(decodeFormStringToForm(form_string));
+        }
+        static FormId decodeFormStringToForm(const char* form_string) {
+            return boost::get_optional_value_or(form_handling::from_string(form_string), FormId::Zero);
+        }
+        static skse::string_ref encodeFormToString(FormId id) {
+            return skse::string_ref{ boost::get_optional_value_or(form_handling::to_string(id), "") };
+        }
+        static skse::string_ref encodeFormIdToString(UInt32 id) {
+            return encodeFormToString( util::to_enum<FormId>(id) );
+        }
+
+        REGISTERF2(decodeFormStringToFormId, "formString", "FormId|Form <-> \"__formData|<pluginName>|<lowFormId>\"-string converisons");
+        REGISTERF2(decodeFormStringToForm, "formString", "");
+        REGISTERF2(encodeFormToString, "value", "");
+        REGISTERF2(encodeFormIdToString, "formId", "");
     };
 
     TES_META_INFO(tes_string);
diff --git a/JContainers/src/api_3/collections.tests.hpp b/JContainers/src/api_3/tests.hpp
similarity index 95%
rename from JContainers/src/api_3/collections.tests.hpp
rename to JContainers/src/api_3/tests.hpp
index 18ce91f..c472994 100644
--- a/JContainers/src/api_3/collections.tests.hpp
+++ b/JContainers/src/api_3/tests.hpp
@@ -107,7 +107,7 @@ namespace tes_api_3 {
         EXPECT_TRUE(!tes_jcontainers::fileExistsAtPath("abracadabra"));
     }
 
-    TEST(path_resolving, collection_operators)
+    TEST(path_resolving, collections_operators)
     {
         auto shouldReturnNumber = [&](object_base *obj, const char *path, float value) {
             path_resolving::resolve(tes_context::instance(), obj, path, [&](item * item) {
@@ -198,7 +198,7 @@ namespace tes_api_3 {
             ++itr;
             key = tes_map_ext::nextKey<std::string>(m, key.c_str());
         }
-        EXPECT_TRUE(itr == m->u_container().end())
+        EXPECT_TRUE(itr == m->u_container().end());
     }
 
     TEST(tes_object, pool)
diff --git a/JContainers/src/path_resolving.cpp b/JContainers/src/collections/access.cpp
similarity index 87%
rename from JContainers/src/path_resolving.cpp
rename to JContainers/src/collections/access.cpp
index f0c4a11..c253128 100644
--- a/JContainers/src/path_resolving.cpp
+++ b/JContainers/src/collections/access.cpp
@@ -1,4 +1,4 @@
-#include "path_resolving.h"
+#include "collections/access.h"
 
 #include <boost/algorithm/string.hpp>
 #include <boost/range/iterator_range.hpp>
@@ -7,11 +7,11 @@
 
 #include <functional>
 
-#include "collections.h"
-#include "form_handling.h"
-#include "tes_context.h"
+#include "collections/collections.h"
+#include "collections/form_handling.h"
+#include "collections/context.h"
 
-#include "collection_operators.h"
+#include "collections/operators.h"
 
 namespace collections
 {
@@ -46,7 +46,7 @@ namespace collections
         };
 
         template<class T>
-        static bool _map_visit_helper(tes_context& context, T& container, path_type path, std::function<void(item *)> function)
+        static bool _map_visit_helper(tes_context& context, T& container, path_type path, std::function<void(item *)>&& function)
         {
             if (path.empty()) {
                 return false;
@@ -84,7 +84,9 @@ namespace collections
             return true;
         }
 
-        void resolve(tes_context& context, item& target, const char *cpath, std::function<void(item *)>  itemFunction, bool createMissingKeys) {
+        void resolve(tes_context& context, item& target, const char *cpath,
+            const std::function<void(item *)>& itemFunction, bool createMissingKeys)
+        {
             if (!cpath) {
                 return;
             }
@@ -97,7 +99,9 @@ namespace collections
             }
         }
 
-        void resolve(tes_context& context, object_base *collection, const char *cpath, std::function<void(item *)>  itemFunction, bool createMissingKeys) {
+        void resolve(tes_context& context, object_base *collection, const char *cpath,
+            const std::function<void(item *)>& itemFunction, bool createMissingKeys)
+        {
 
             if (!collection || !cpath) {
                 return;
@@ -138,7 +142,7 @@ namespace collections
                     return state(false, st);
                 }
 
-                auto opr = collection_operators::get_operator(operationStr.c_str());
+                auto opr = operators::get_operator(operationStr.c_str());
 
                 if (!opr) {
                     return state(false, st);
@@ -233,7 +237,7 @@ namespace collections
                                 path_type(end, path.end()) );
             };
 
-            auto arrayRule = [](const state &st) -> state {
+            auto arrayRule = [&context](const state &st) -> state {
 
                 const auto& path = st.path;
 
@@ -250,6 +254,7 @@ namespace collections
                 }
 
                 int32_t indexOrFormId = 0;
+                FormId frmId = FormId::Zero;
 
                 if (!form_handling::is_form_string(indexRange.begin())) {
                     try {
@@ -268,7 +273,7 @@ namespace collections
                         return state(false, st);
                     }
 
-                    indexOrFormId = *fId;
+                    frmId = *fId;
                 }
 
                 object_lock lock(st.object);
@@ -279,12 +284,12 @@ namespace collections
                 }
 
                 return state(   true,
-                                [=](object_base* container) {
+                                [=, &context](object_base* container) {
                                     if (container->as<array>()) {
                                         return container->as<array>()->u_get(indexOrFormId);
                                     }
                                     else if (container->as<form_map>()) {
-                                        return container->as<form_map>()->u_get((FormId)indexOrFormId);
+                                        return container->as<form_map>()->u_get(make_weak_form_id(frmId, context));
                                     }
                                     else if (container->as<integer_map>()) {
                                         return container->as<integer_map>()->u_get(indexOrFormId);
@@ -337,18 +342,21 @@ namespace collections
 
         namespace bs = boost;
 
-        using string = std::string;
+        using std::forward;
+        using std::string;
+
+        namespace {
         using cstring = bs::iterator_range<const char*>;
         //using keys = std::vector<key_variant>;
 
         template<class R, class Arg, class F1, class ... F>
         boost::optional<R> parse_path_helper(Arg&& a, F1&& f1, F&& ... funcs) {
-            auto result = f1(a);
+            auto result = f1(std::forward<Arg>(a));
             if (result) {
                 return result;
             }
             else {
-                return parse_path_helper<R>(a, funcs...);
+                return parse_path_helper<R>(std::forward<Arg>(a), std::forward<F>(funcs)...);
             }
         };
 
@@ -362,14 +370,13 @@ namespace collections
             cstring rest_of_path;
         };
 
-        bs::optional<key_and_rest> parse_path(const cstring& path) {
+        template<class Context>
+        bs::optional<key_and_rest> parse_path(Context& context, const cstring& path) {
 
             if (path.empty()) {
                 return bs::none;
             }
 
-            typedef bs::optional<key_and_rest>(*rule)(const cstring &);
-
             auto mapRule = [](const cstring &path)-> bs::optional < key_and_rest > {
 
                 if (!bs::starts_with(path, ".") || path.size() < 2) {
@@ -387,7 +394,7 @@ namespace collections
                 return key_and_rest{ std::move(str), cstring(end, path.end()) };
             };
 
-            auto arrayRule = [](const cstring &path)-> bs::optional < key_and_rest > {
+            auto arrayRule = [&context](const cstring &path)-> bs::optional < key_and_rest > {
 
                 if (!bs::starts_with(path, "[") || path.size() < 3) {
                     return bs::none;
@@ -421,15 +428,13 @@ namespace collections
                         return bs::none;
                     }
 
-                    return key_and_rest{ *fId, cstring(end + 1, path.end()) };
+                    return key_and_rest{ make_weak_form_id(*fId, context), cstring(end + 1, path.end()) };
                 }
             };
 
             return parse_path_helper<key_and_rest>(path, arrayRule, mapRule);
         }
 
-
-
         struct constant_accessor {
             static bs::optional<object_base*> access_value(object_base& collection, const bs::optional<key_and_rest>& key) {
                 if (!key) {
@@ -455,7 +460,7 @@ namespace collections
                 */
                 if (!itemPtr) {
                     itemPtr = u_assign_value(collection, key->key, item());
-                    auto next_key = parse_path(key->rest_of_path);
+                    auto next_key = parse_path(HACK_get_tcontext(collection), key->rest_of_path);
                     if (itemPtr && next_key) {
                         struct creator : public bs::static_visitor<object_base*> {
                             object_context* ctx;
@@ -463,7 +468,7 @@ namespace collections
 
                             object_base* operator ()(const int32_t& k) const { return &integer_map::object(*ctx); }
                             object_base* operator ()(const string& k) const { return &map::object(*ctx); }
-                            object_base* operator ()(const FormId& k) const { return &form_map::object(*ctx); }
+                            object_base* operator ()(const form_ref& k) const { return &form_map::object(*ctx); }
                         };
                         *itemPtr = bs::apply_visitor(creator(&collection.context()), next_key->key);
                     }
@@ -482,7 +487,7 @@ namespace collections
             retrieve obj -> str -> (obj, key)
             retrieve obj str = recurs obj[(key, rest)] (key, rest) obj
                                 where
-                                   (key, rest) = parse str
+                                    (key, rest) = parse str
 
             recurs v    (key, rest)     src = recurs v[(nkey, nrest)] (nkey, nrest) v where (nkey, nrest) = parse rest
             recurs V    (key, Nothing)  src = (src, key)
@@ -492,7 +497,7 @@ namespace collections
             */
 
             static bs::optional<accesss_info> retrieve(object_base& collection, const cstring& path) {
-                auto key_opt = parse_path(path);
+                auto key_opt = parse_path(HACK_get_tcontext(collection), path);
                 return recurs(access_value::access_value(collection, key_opt), key_opt, collection);
             }
 
@@ -507,7 +512,7 @@ namespace collections
                     return accesss_info{ source, std::move(k->key) };
                 }
                 else if (as_object && !k->rest_of_path.empty()) {
-                    auto next_key = parse_path(k->rest_of_path);
+                    auto next_key = parse_path(HACK_get_tcontext(source), k->rest_of_path);
                     return recurs(access_value::access_value(*as_object, next_key), next_key, *as_object);
                 }
                 else {
@@ -516,40 +521,18 @@ namespace collections
             }
         };
 
-        template<class Visitor>
-        void resolve_templ(tes_context& context, object_base& collection, const char* cpath, Visitor& itemFunction, bool create_missing_keys = false) {
-
-            assert(cpath);
-
-            // path is empty -> just visit collection
-            if (!*cpath) {
-                item itm(collection);
-                itemFunction(&itm);
-                return;
-            }
-
-            auto all_path = bs::make_iterator_range(cpath, cpath + strnlen_s(cpath, 1024));
-            auto access_inf = create_missing_keys
-                ? last_kv_pair_retriever<creative_accessor>::retrieve(collection, all_path)
-                : last_kv_pair_retriever<constant_accessor>::retrieve(collection, all_path);
-
-            if (access_inf) {
-                object_lock g(access_inf->collection);
-                auto itemPtr = u_access_value(access_inf->collection, access_inf->key);
-                itemFunction(itemPtr);
-            }
-            else {
-                itemFunction(nullptr);
-            }
+        enum {
+            collection_path_limit = 1024,
+        };
         }
 
         bs::optional<accesss_info> access_constant(object_base& collection, const char* cpath) {
-            auto all_path = bs::make_iterator_range(cpath, cpath + strnlen_s(cpath, 1024));
+            auto all_path = bs::make_iterator_range(cpath, cpath + strnlen_s(cpath, collection_path_limit));
             return last_kv_pair_retriever<constant_accessor>::retrieve(collection, all_path);
         }
 
         bs::optional<accesss_info> access_creative(object_base& collection, const char* cpath) {
-            auto all_path = bs::make_iterator_range(cpath, cpath + strnlen_s(cpath, 1024));
+            auto all_path = bs::make_iterator_range(cpath, cpath + strnlen_s(cpath, collection_path_limit));
             return last_kv_pair_retriever<creative_accessor>::retrieve(collection, all_path);
         }
     }
diff --git a/JContainers/src/path_resolving.h b/JContainers/src/collections/access.h
similarity index 93%
rename from JContainers/src/path_resolving.h
rename to JContainers/src/collections/access.h
index 524befb..63e0db0 100644
--- a/JContainers/src/path_resolving.h
+++ b/JContainers/src/collections/access.h
@@ -5,7 +5,8 @@
 #include <boost/optional.hpp>
 #include <boost/variant/variant.hpp>
 
-#include "collections.h"
+#include "collections/collections.h"
+#include "collections/default_value.h"
 
 namespace collections
 {
@@ -15,12 +16,14 @@ namespace collections
 
     namespace path_resolving {
 
-        void resolve(tes_context& ctx, item& target, const char *cpath, std::function<void(item *)> itemFunction, bool createMissingKeys = false);
+        void resolve(tes_context& ctx, item& target, const char *cpath,
+            const std::function<void(item *)>& itemFunction, bool createMissingKeys = false);
 
-        void resolve(tes_context& ctx, object_base *target, const char *cpath, std::function<void(item *)> itemFunction, bool createMissingKeys = false);
+        void resolve(tes_context& ctx, object_base *target, const char *cpath,
+            const std::function<void(item *)>& itemFunction, bool createMissingKeys = false);
 
         template<class T>
-        inline T _resolve(tes_context& ctx, object_base *target, const char *cpath, T def = T(0)) {
+        inline T _resolve(tes_context& ctx, object_base *target, const char *cpath, T def = default_value<T>()) {
             resolve(ctx, target, cpath, [&](item *itm) {
                 if (itm) {
                     def = itm->readAs<T>();
@@ -35,7 +38,7 @@ namespace collections
     namespace ca {
         namespace bs = boost;
 
-        using key_variant = boost::variant<int32_t, std::string, FormId>;
+        using key_variant = boost::variant<int32_t, std::string, form_ref>;
 
         struct u_access_value_helper {
             template<class Collection>
@@ -63,6 +66,11 @@ namespace collections
             }
         };
 
+        template<class Value>
+        inline auto u_assign_value(object_base& collection, const key_variant& key, Value&& value) -> item* {
+            return perform_on_object_and_return<item* >(collection, u_assign_value_helper<Value>(), key, std::forward<Value>(value));
+        }
+
         struct accesss_info {
             object_base& collection;
             key_variant key;
@@ -81,10 +89,6 @@ namespace collections
         bs::optional<accesss_info> access_constant(object_base& tree, const char* path);
         bs::optional<accesss_info> access_creative(object_base& tree, const char* path);
 
-        template<class Value>
-        inline auto u_assign_value(object_base& collection, const key_variant& key, Value&& value) -> item* {
-            return perform_on_object_and_return<item* >(collection, u_assign_value_helper<Value>(), key, std::forward<Value>(value));
-        }
 
         inline bs::optional<item> get(object_base& target, const char *cpath) {
             auto ac_info = access_constant(target, cpath);
diff --git a/JContainers/src/collection_bind_traits.h b/JContainers/src/collections/bind_traits.h
similarity index 23%
rename from JContainers/src/collection_bind_traits.h
rename to JContainers/src/collections/bind_traits.h
index e5a986a..ddcaeb5 100644
--- a/JContainers/src/collection_bind_traits.h
+++ b/JContainers/src/collections/bind_traits.h
@@ -1,103 +1,78 @@
 #pragma once
 
-#include "tes_binding.h"
-#include "collections.h"
-#include "tes_context.h"
+#include "util/stl_ext.h"
+#include "skse/skse.h"
+#include "reflection/tes_binding.h"
+#include "collections/collections.h"
+#include "collections/context.h"
 
 namespace reflection { namespace binding {
 
     using namespace collections;
 
+    template<class T = object_base>
     struct ObjectConverter {
 
         typedef HandleT tes_type;
 
         static HandleT convert2Tes(object_base* obj) {
-            return obj ? obj->uid() : 0;
+            return (HandleT)(obj ? obj->uid() : Handle::Null);
         }
 
-        static object_stack_ref convert2J(HandleT hdl) {
-            return tes_context::instance().getObjectRef((Handle)hdl);
-        }
-
-    };
-
-    template<class T, class P> struct GetConv < boost::intrusive_ptr_jc<T, P>& > : ObjectConverter{
-        static boost::intrusive_ptr_jc<T, P> convert2J(HandleT hdl) {
-            return tes_context::instance().getObjectRefOfType<T>((Handle)hdl);
+        static object_stack_ref_template<T> convert2J(HandleT hdl) {
+            auto ref = tes_context::instance().getObjectRefOfType<T>((Handle)hdl);
+            if (!ref && hdl != util::to_integral(Handle::Null)) {
+                JC_log("Warning: access to non-existing object with id 0x%X", hdl);
+            }
+            return ref;
         }
     };
 
-    template<class T>
-    struct ObjectConverterT {
+    template<> struct GetConv < object_stack_ref > : ObjectConverter<>{};
 
-        typedef HandleT tes_type;
-
-        static HandleT convert2Tes(object_base* obj) {
-            return obj ? obj->uid() : 0;
-        }
-
-        static typename T::ref convert2J(HandleT hdl) {
-            return tes_context::instance().getObjectRefOfType<T>((Handle)hdl);
-        }
-    };
-
-    template<> struct GetConv < object_stack_ref& > : ObjectConverter{};
-    //template<> struct GetConv < object_stack_ref > : ObjectConverter{};
-
-    template<> struct GetConv < object_base* > : ObjectConverter{};
-    template<> struct GetConv < array* > : ObjectConverterT< array >{};
-    template<> struct GetConv < map* > : ObjectConverterT< map >{};
-    template<> struct GetConv < form_map* > : ObjectConverterT< form_map >{};
-    template<> struct GetConv < integer_map* > : ObjectConverterT < integer_map >{};
+    template<> struct GetConv < object_base* > : ObjectConverter<>{};
+    template<> struct GetConv < array* > : ObjectConverter< array >{};
+    template<> struct GetConv < map* > : ObjectConverter< map >{};
+    template<> struct GetConv < form_map* > : ObjectConverter< form_map >{};
+    template<> struct GetConv < integer_map* > : ObjectConverter < integer_map >{};
 
     //////////////////////////////////////////////////////////////////////////
 
-    template<> struct GetConv < Handle > {
-        typedef HandleT tes_type;
-
-        static HandleT convert2Tes(Handle obj) {
-            return obj;
-        }
-        static Handle convert2J(HandleT hdl) {
-            return static_cast<Handle>(hdl);
-        }
-    };
+    template<> struct GetConv < Handle > : StaticCastValueConverter<Handle, HandleT> {};
 
     //////////////////////////////////////////////////////////////////////////
 
     template<> struct GetConv < FormId > {
         typedef TESForm* tes_type;
         static TESForm* convert2Tes(FormId id) {
-            return LookupFormByID(id);
+            return LookupFormByID((uint32_t)id);
         }
         static FormId convert2J(const TESForm* form) {
-            return form ? (FormId)form->formID : FormZero;
+            return form ? (FormId)form->formID : FormId::Zero;
         }
     };
 
-    template<> struct j2Str < FormId > : j2Str < TESForm* > {};
-
-
-    //////////////////////////////////////////////////////////////////////////
-
-    template<class T, class P> struct j2Str < boost::intrusive_ptr_jc<T, P> > {
-        static function_parameter typeInfo() { return j2Str<T*>::typeInfo(); }
-    };
+    /////////////////
 
-    template<class T, class P> struct j2Str < boost::intrusive_ptr_jc<T, P>& > {
-        static function_parameter typeInfo() { return j2Str<T*>::typeInfo(); }
+    template<> struct GetConv < form_watching::form_ref > {
+        typedef TESForm* tes_type;
+        static TESForm* convert2Tes(const form_watching::form_ref& id) {
+            return skse::lookup_form(id.get());
+        }
+        static form_watching::form_ref convert2J(const TESForm* form) {
+            return make_weak_form_id(form, tes_context::instance());
+        }
     };
 
-    struct jc_object_type_info {
-        static function_parameter typeInfo() { return function_parameter_make("int", "object"); }
+    template<> struct GetConv < form_watching::form_ref_lightweight > {
+        typedef TESForm* tes_type;
+        static TESForm* convert2Tes(const form_watching::form_ref_lightweight& id) {
+            return skse::lookup_form(id.get());
+        }
+        static form_watching::form_ref_lightweight convert2J(const TESForm* form) {
+            return make_lightweight_form_ref(form, tes_context::instance());
+        }
     };
 
-    template<> struct j2Str < object_base * > : jc_object_type_info{};
-    template<> struct j2Str < map * > : jc_object_type_info{};
-    template<> struct j2Str < array * > : jc_object_type_info{};
-    template<> struct j2Str < form_map * > : jc_object_type_info{};
-    template<> struct j2Str < integer_map * > : jc_object_type_info{};
-    template<> struct j2Str < Handle > : jc_object_type_info{};
 }
 }
diff --git a/JContainers/src/collections.cpp b/JContainers/src/collections/collections.cpp
similarity index 38%
rename from JContainers/src/collections.cpp
rename to JContainers/src/collections/collections.cpp
index e4ba653..a134cdc 100644
--- a/JContainers/src/collections.cpp
+++ b/JContainers/src/collections/collections.cpp
@@ -6,6 +6,9 @@
 #include <boost/serialization/vector.hpp>
 #include <boost/serialization/map.hpp>
 #include <boost/serialization/variant.hpp>
+#include <boost/serialization/shared_ptr.hpp>
+#include <boost/serialization/weak_ptr.hpp>
+#include <boost/serialization/hash_map.hpp>
 
 #include <boost/serialization/split_member.hpp>
 #include <boost/serialization/split_free.hpp>
@@ -20,126 +23,50 @@
 #include <set>
 
 #include "gtest.h"
+#include "util/stl_ext.h"
 
 #include "intrusive_ptr.hpp"
 #include "intrusive_ptr_serialization.hpp"
 #include "util/istring_serialization.h"
+#include "iarchive_with_blob.h"
 
 #include "object/object_base_serialization.h"
 
-#include "collections.h"
-#include "tes_context.h"
-#include "form_handling.h"
+#include "collections/collections.h"
+#include "collections/context.h"
+#include "collections/form_handling.h"
 
-#include "tes_context.hpp"
+#include "collections/context.hpp"
+#include "collections/dyn_form_watcher.hpp"
 
 BOOST_CLASS_EXPORT_GUID(collections::array, "kJArray");
 BOOST_CLASS_EXPORT_GUID(collections::map, "kJMap");
 BOOST_CLASS_EXPORT_GUID(collections::form_map, "kJFormMap");
 BOOST_CLASS_EXPORT_GUID(collections::integer_map, "kJIntegerMap");
 
-BOOST_CLASS_VERSION(collections::item, 2)
+BOOST_CLASS_VERSION(collections::form_map, 1)
+BOOST_CLASS_VERSION(collections::item, 3)
 
 BOOST_CLASS_IMPLEMENTATION(boost::blank, boost::serialization::primitive_type);
 
 namespace collections {
 
-    // 0.67 to 0.68:
-    namespace conv_067_to_3 {
-
-        struct old_blank {
-            template<class Archive>
-            void serialize(Archive & ar, const unsigned int version) {}
-        };
-
-        struct object_ref_old {
-            object_base *px = nullptr;
-
-            template<class Archive>
-            void serialize(Archive & ar, const unsigned int version) {
-                ar & px;
-            }
-        };
-
-        struct item_converter : boost::static_visitor < > {
-            item::variant& varNew;
-        
-            explicit item_converter(item::variant& var) : varNew(var) {}
-
-            template<class T> void operator() (T& val) {
-                varNew = std::move(val);
-            }
-
-            void operator()(old_blank& val) {}
-
-            void operator()(object_ref_old& val) {
-                varNew = internal_object_ref(val.px);
-            }
-        };
-
-        template<class A> void do_conversion(A& ar, item::variant& varNew) {
-            typedef boost::variant<old_blank, SInt32, Float32, FormId, object_ref_old, std::string> variant_old;
-            variant_old varOld;
-            ar >> varOld;
-
-            item_converter converter(varNew);
-            boost::apply_visitor(converter, varOld);
+    template<class Archive>
+    struct converter_324_to_330 : public boost::static_visitor < > {
+        template<class T> void operator () ( T& v) {
+            var = std::move(v);
         }
-    }
-    
-    namespace conv_066 {
-        // deprecate in 0.67:
-        enum ItemType : unsigned char {
-            ItemTypeNone = 0,
-            ItemTypeInt32 = 1,
-            ItemTypeFloat32 = 2,
-            ItemTypeCString = 3,
-            ItemTypeObject = 4,
-            ItemTypeForm = 5,
-        };
-
-        template<class Archive>
-        void read(Archive & ar, item& itm) {
-            ItemType type = ItemTypeNone;
-            ar & type;
-
-            switch (type) {
-            case ItemTypeInt32: {
-                SInt32 val = 0;
-                ar & val;
-                itm = val;
-                break;
-            }
-            case ItemTypeFloat32: {
-                Float32 val = 0;
-                ar & val;
-                itm = val;
-                break;
-            }
-            case ItemTypeCString: {
-                std::string string;
-                ar & string;
-                itm = string;
-                break;
-            }
-            case ItemTypeObject: {
-                object_base *object = nullptr;
-                ar & object;
-                itm.var() = internal_object_ref(object, false);
-                break;
-            }
-            case ItemTypeForm: {
-                UInt32 oldId = 0;
-                ar & oldId;
-                itm.var() = (FormId)oldId;
-                break;
-            }
-            default:
-                break;
-            }
+        void operator () ( FormId& v) {
+            auto& fwatcher = hack::iarchive_with_blob::from_base_get<tes_context>(archive)._form_watcher;
+            var = form_ref{ v, fwatcher, form_ref::load_old_id };
         }
-    }
+        item::variant& var;
+        Archive& archive;
 
+        explicit converter_324_to_330(item::variant& var_, Archive& archive_) : var(var_), archive(archive_) {}
+    };
+    
+    
     template<class Archive>
     void item::load(Archive & ar, const unsigned int version)
     {
@@ -148,20 +75,16 @@ namespace collections {
         default:
             BOOST_ASSERT(false);
             break;
-        case 2:
-            ar & _var;
-            break;
-        case 1: {
-            conv_067_to_3::do_conversion(ar, _var);
-            break;
+        case 2: { // v 3.2.X and below
+            using variant_old = boost::variant<boost::blank, SInt32, Real, FormId, internal_object_ref, std::string>;
+            variant_old var;
+            ar >> var;
+            var.apply_visitor(converter_324_to_330<Archive>{ _var, ar });
         }
-        case 0:
-            conv_066::read(ar, *this);
             break;
-        }
-
-        if (auto fId = get<FormId>()) {
-            *this = form_handling::resolve_handle(*fId);
+        case 3:
+            ar & _var;
+            break;
         }
     }
 
@@ -185,12 +108,38 @@ namespace collections {
     }
 
     template<class Archive>
-    void form_map::serialize(Archive & ar, const unsigned int version) {
+    void form_map::save(Archive & ar, const unsigned int version) const {
         ar & boost::serialization::base_object<object_base>(*this);
         ar & cnt;
     }
 
     template<class Archive>
+    void form_map::load(Archive & ar, const unsigned int version) {
+        ar & boost::serialization::base_object<object_base>(*this);
+
+        switch (version) {
+        default:
+            BOOST_ASSERT_MSG(false, "invalid form_map version");
+            break;
+        case 0: {   // v3.2.X -> v3.3.X
+            std::map<FormId, item> oldMap;
+            ar >> oldMap;
+            auto& fwatcher = hack::iarchive_with_blob::from_base_get<tes_context>(ar)._form_watcher;
+            for (auto& pair : oldMap) {
+                form_ref key{ pair.first, fwatcher, form_ref::load_old_id };
+                if (key) {
+                    cnt.emplace(value_type{ std::move(key), std::move(pair.second) });
+                }
+            }
+        }
+            break;
+        case 1:
+            ar & cnt;
+            break;
+        }
+    }
+
+    template<class Archive>
     void integer_map::serialize(Archive & ar, const unsigned int version) {
         ar & boost::serialization::base_object<object_base>(*this);
         ar & cnt;
@@ -200,37 +149,9 @@ namespace collections {
 
     void form_map::u_onLoaded() {
 
-        for (auto itr = cnt.begin(); itr != cnt.end(); ) {
-
-            const FormId& oldKey = itr->first;
-            FormId newKey = form_handling::resolve_handle(oldKey);
-
-            if (oldKey == newKey) {
-                ++itr; // fine
-            }
-            else if (newKey == FormZero) {
-                itr = cnt.erase(itr);
-            }
-            else if (oldKey != newKey) { // and what if newKey will replace another oldKey???
-
-                // There is one issue. Given two plugins
-                // .... A ... B..
-                // both plugins gets swapped
-                // and two form Id's swapped too: 0xaa001 swapped with 0xbb001
-                // the form-id from the A replaces the form-id from the B
-
-                auto anotherOldKeyItr = cnt.find(newKey);
-                if (anotherOldKeyItr != cnt.end()) { // exactly that rare case, newKey equals to some other oldKey
-                    // do not insert as it will replace other oldKey, SWAP values instead
-                    std::swap(anotherOldKeyItr->second, itr->second);
-                    ++itr;
-                }
-                else {
-                    cnt.insert(container_type::value_type(newKey, std::move(itr->second)));
-                    itr = cnt.erase(itr);
-                }
-            }
-        }
+        util::tree_erase_if(cnt, [](const value_type& pair){
+            return pair.first.is_expired();
+        });
     }
 
     //////////////////////////////////////////////////////////////////////////
diff --git a/JContainers/src/collections.h b/JContainers/src/collections/collections.h
similarity index 74%
rename from JContainers/src/collections.h
rename to JContainers/src/collections/collections.h
index a942960..9d9cf0f 100644
--- a/JContainers/src/collections.h
+++ b/JContainers/src/collections/collections.h
@@ -10,13 +10,11 @@
 #include "common/ITypes.h"
 #include "common/IDebugLog.h"
 #include "skse/GameForms.h"
+#include "skse/skse.h"
 
-//#include "tes_context.h"
 #include "object/object_base.h"
-#include "skse.h"
 
-#include "collection_item.h"
-#include "collection_types.h"
+#include "collections/item.h"
 
 namespace collections {
 
@@ -36,7 +34,7 @@ namespace collections {
 
     public:
 
-        // just for convence to not use static_cast's
+        // just for convinience - to not use static_cast's
         object_base& base() { return *this; }
         const object_base& base() const { return *this; }
 
@@ -69,7 +67,6 @@ namespace collections {
         }
     };
 
-    
     template<class R, class Collection, class F, class ...Args>
     inline R perform_on_object_and_return(Collection& container, F func, Args&&... args) {
         switch (container.type()) {
@@ -150,7 +147,7 @@ namespace collections {
 
         template<class T> void push(T&& item) {
             object_lock g(this);
-            u_push(item);
+            u_push(std::forward<T>(item));
         }
 
         template<class T> void u_push(T&& item) {
@@ -192,6 +189,16 @@ namespace collections {
             return const_cast<item*>( const_cast<const array*>(this)->u_get(index) );
         }
 
+        boost::optional<item> u_erase_and_return(int32_t index) {
+            auto idx = u_convertIndex(index);
+            if (idx) {
+                boost::optional<item> var(std::move(_array[*idx]));
+                _array.erase(_array.begin() + *idx);
+                return var;
+            }
+            return boost::none;
+        }
+
         template<class T>
         item* u_set(int32_t index, T&& itm) {
             auto idx = u_convertIndex(index);
@@ -207,6 +214,11 @@ namespace collections {
             u_set(index, std::forward<T>(itm));
         }
 
+        template<class T>
+        static boost::optional<T> _opt_from_pointer(const T* t) {
+            return t ? boost::optional<T>(*t) : boost::none;
+        }
+
         item& operator [] (int32_t index) { return const_cast<item&>(const_cast<const array*>(this)->operator[](index)); }
         const item& operator [] (int32_t index) const {
             auto idx = u_convertIndex(index);
@@ -216,8 +228,7 @@ namespace collections {
 
         boost::optional<item> get_item(int32_t index) const {
             object_lock lock(this);
-            auto idx = u_convertIndex(index);
-            return idx ? boost::optional<item>(_array[*idx]) : boost::none;
+            return _opt_from_pointer(u_get(index));
         }
 
         iterator begin() { return _array.begin();}
@@ -236,11 +247,17 @@ namespace collections {
     template<class RealType, class ContainerType>
     class basic_map_collection : public collection_base< RealType > {
     public:
-        typedef ContainerType container_type;
-        typedef typename ContainerType::key_type key_type;
+        using container_type = ContainerType;
+        using value_type = typename container_type::value_type;
+        using key_type = typename ContainerType::key_type;
+        using iterator = typename container_type::iterator;
+        using const_iterator = typename container_type::const_iterator;
     protected:
         ContainerType cnt;
 
+        template<class ContainerType>
+        static util::choose_iterator<ContainerType> _find(ContainerType& c, const key_type& k) { return c.find(k); }
+
     public:
 
         const container_type& u_container() const {
@@ -251,39 +268,52 @@ namespace collections {
             return cnt;
         }
 
-        container_type container_copy() {
+        container_type container_copy() const {
             object_lock g(this);
             return cnt;
         }
 
-        item findOrDef(const key_type& key) const {
+        template<class Key>
+        item findOrDef(const Key& key) const {
             object_lock g(this);
             auto result = u_get(key);
             return result ? *result : item();
         }
 
-        boost::optional<item> get_item(const key_type& key) const {
+        template<class Key>
+        boost::optional<item> get_item(const Key& key) const {
             object_lock g(this);
             auto result = u_get(key);
             return result ? *result : boost::optional<item>();
         }
 
-        const item* u_get(const key_type& key) const {
-            auto itr = cnt.find(key);
+        item& u_get_or_create(const key_type& key) {
+            return cnt[key];
+        }
+
+        template<class Key>
+        const item* u_get(const Key& key) const {
+            auto itr = RealType::_find(cnt, key);
             return itr != cnt.end() ? &(itr->second) : nullptr;
         }
 
-        item* u_get(const key_type& key) {
+        template<class Key>
+        item* u_get(const Key& key) {
             return const_cast<item*>( const_cast<const basic_map_collection*>(this)->u_get(key) );
         }
 
-        bool erase(const key_type& key) {
+        template<class Key>
+        const_iterator u_find_iterator(const Key& k) const { return RealType::_find(cnt, k); }
+
+        template<class Key>
+        bool erase(const Key& key) {
             object_lock g(this);
             return u_erase(key);
         }
 
-        bool u_erase(const key_type& key) {
-            auto itr = cnt.find(key);
+        template<class Key>
+        bool u_erase(const Key& key) {
+            typename container_type::iterator itr = RealType::_find(cnt, key);
             return itr != cnt.end() ? (cnt.erase(itr), true) : false;
         }
 
@@ -291,11 +321,11 @@ namespace collections {
             cnt.clear();
         }
 
-        template<class T> item* u_set(const key_type& key, T&& value) {
+        template<class T, class Key> item* u_set(const Key& key, T&& value) {
             return &(cnt[key] = std::forward<T>(value));
         }
 
-        template<class T> void set(const key_type& key, T&& value) {
+        template<class T, class Key> void set(const Key& key, T&& value) {
             object_lock g(this);
             u_set(key, std::forward<T>(value));
         }
@@ -304,11 +334,13 @@ namespace collections {
             return cnt.size();
         }
 
-        item& operator [] (const key_type& key) {
+        template<class Key>
+        item& operator [] (const Key& key) {
             return const_cast<item&>(const_cast<const basic_map_collection&>(*this)[key]);
         }
 
-        const item& operator [] (const key_type& key) const {
+        template<class Key>
+        const item& operator [] (const Key& key) const {
             auto itm = u_get(key);
             assert(itm);
             return *itm;
@@ -349,9 +381,33 @@ namespace collections {
         void serialize(Archive & ar, const unsigned int version);
     };
 
-
-    class form_map : public basic_map_collection< form_map, std::map<FormId, item> >
+    class form_map : public basic_map_collection< form_map, std::map<form_ref, item, form_ref::stable_less_comparer> >
     {
+    private:
+        using base = basic_map_collection< form_map, std::map<form_ref, item, form_ref::stable_less_comparer> >;
+
+    public:
+
+        // form_ref_lightweight support
+
+        using base::_find;
+        using base::u_get_or_create;
+
+        template<class ContainerType>
+        static util::choose_iterator<ContainerType> _find(ContainerType& c, const form_ref_lightweight& k) {
+            auto comparer = c.key_comp();
+            auto itr = std::lower_bound(c.begin(), c.end(), k,
+                [comparer](const form_map::value_type& pair, const form_ref_lightweight& k) {
+                    return comparer(pair.first, k);
+                }
+            );
+            return itr != c.end() && itr->first == k ? itr : c.end();
+        }
+
+        item& u_get_or_create(const form_ref_lightweight& key) {
+            return cnt[key.to_form_ref()];
+        }
+
     public:
         enum  {
             TypeId = CollectionType::FormMap,
@@ -361,8 +417,13 @@ namespace collections {
 
         //////////////////////////////////////////////////////////////////////////
 
+        friend class boost::serialization::access;
+        BOOST_SERIALIZATION_SPLIT_MEMBER();
+
         template<class Archive>
-        void serialize(Archive & ar, const unsigned int version);
+        void load(Archive & ar, const unsigned int version);
+        template<class Archive>
+        void save(Archive & ar, const unsigned int version) const;
     };
 
     class integer_map : public basic_map_collection < integer_map, std::map<int32_t, item> >
diff --git a/JContainers/src/tes_context.h b/JContainers/src/collections/context.h
similarity index 30%
rename from JContainers/src/tes_context.h
rename to JContainers/src/collections/context.h
index 8d6ecd3..4e53af8 100644
--- a/JContainers/src/tes_context.h
+++ b/JContainers/src/collections/context.h
@@ -6,9 +6,10 @@
 #include "util/spinlock.h"
 #include "object/object_base.h"
 #include "object/object_context.h"
-#include "tes_error_code.h"
 
-#include "collections.h"
+//#include "collections/error_code.h"
+#include "collections/collections.h"
+#include "collections/dyn_form_watcher.h"
 
 namespace collections
 {
@@ -16,6 +17,11 @@ namespace collections
 
     class tes_context : public object_context
     {
+        using base = object_context;
+
+        void u_print_stats() const;
+        void u_applyUpdates(const serialization_version saveVersion);
+
     public:
 
         using post_init = ::meta<void(*)(tes_context&)>;
@@ -26,36 +32,24 @@ namespace collections
             }
         }
 
-        static tes_context& instance() {
-            static tes_context st;
-            return st;
+        ~tes_context() {
+            shutdown();
         }
 
-        object_stack_ref_template<map> database_ref() {
-            return database();
-        }
+        static tes_context& instance();
 
-        map* database() {
-            object_base * result = getObject(_root_object_id);
+    private:
 
-            if (!result) {
-                _lazyDBLock.lock();
+        std::atomic<map*> _cached_root = nullptr;
+        std::atomic<Handle> _root_object_id{ Handle::Null };
+        spinlock _lazyRootInitLock;
 
-                result = getObject(_root_object_id);
-                if (!result) {
-                    result = &map::object(*this);
-                    set_root(result);
-                }
+    public:
 
-                _lazyDBLock.unlock();
-            }
+        void set_root(object_base *db);
+        map& root();
 
-            return result->as<map>();
-        }
-
-        void setDataBase(map *db) {
-            set_root(db);
-        }
+    public:
 
         template<class T>
         T * getObjectOfType(Handle hdl) {
@@ -68,8 +62,45 @@ namespace collections
         }
 
         // to attach lua context
-        std::unique_ptr<dependent_context*>     lua_context;
+        std::shared_ptr<dependent_context>     lua_context;
+
+        form_watching::form_observer _form_watcher;
+
+        //////
+    public:
+
+        void read_from_stream(std::istream & stream);
+        void write_to_stream(std::ostream& stream);
+
+        void read_from_string(const std::string & data);
+        std::string write_to_string();
+
+        template<class Archive> void load(Archive & ar, unsigned int version);
+        template<class Archive> void save(Archive & ar, unsigned int version) const;
+        template<class Archive> void load_data_in_old_way(Archive& ar);
+
+        void clearState();
+        // complete shutdown, this context shouldn't be used for now
+        void shutdown();
+
+        friend class boost::serialization::access;
+        BOOST_SERIALIZATION_SPLIT_MEMBER();
+
+    protected:
+
+        void u_clearState() {
+            _root_object_id.store(Handle::Null, std::memory_order_relaxed);
+            _cached_root = nullptr;
+            _form_watcher.u_clearState();
+
+            base::u_clearState();
+        }
 
     };
 
+    // so that this won't be lost or hidden
+    inline tes_context& HACK_get_tcontext(const object_base& obj) {
+        return static_cast<tes_context&>(obj.context());
+    }
+
 }
diff --git a/JContainers/src/collections/context.hpp b/JContainers/src/collections/context.hpp
new file mode 100644
index 0000000..9cd7b23
--- /dev/null
+++ b/JContainers/src/collections/context.hpp
@@ -0,0 +1,269 @@
+#include <boost/iostreams/stream.hpp>
+#include <boost/iostreams/device/array.hpp>
+#include "util/singleton.h"
+
+#include "jansson.h"
+
+BOOST_CLASS_VERSION(collections::tes_context, 1);
+
+namespace collections {
+
+    template<class T, class D>
+    inline std::unique_ptr<T, D> make_unique_ptr(T* data, D destr) {
+        return std::unique_ptr<T, D>(data, destr);
+    }
+
+    struct header {
+
+        serialization_version commonVersion;
+
+        static header imitate_old_header() {
+            return{ serialization_version::no_header };
+        }
+
+        static header make() {
+            return{ serialization_version::current };
+        }
+
+        static const char *common_version_key() { return "commonVersion"; }
+
+        static header read_from_stream(std::istream & stream) {
+
+            uint32_t hdrSize = 0;
+            stream >> hdrSize;
+
+            std::vector<char> buffer(hdrSize);
+            stream.read(&buffer.front(), buffer.size());
+
+            auto js = make_unique_ptr(json_loadb(&buffer.front(), buffer.size(), 0, nullptr), &json_decref);
+            if (!js) { // parsing failed
+                return imitate_old_header();
+            }
+
+            return{ (serialization_version)json_integer_value(json_object_get(js.get(), common_version_key())) };
+        }
+
+        static auto write_to_json() -> decltype(make_unique_ptr((json_t *)nullptr, &json_decref)) {
+            auto header = make_unique_ptr(json_object(), &json_decref);
+
+            json_object_set(header.get(), common_version_key(), json_integer((json_int_t)serialization_version::current));
+
+            return header;
+        }
+
+        static void write_to_stream(std::ostream & stream) {
+            auto header = write_to_json();
+            auto data = make_unique_ptr(json_dumps(header.get(), 0), free);
+
+            uint32_t hdrSize = strlen(data.get());
+            stream << (uint32_t)hdrSize;
+            stream.write(data.get(), hdrSize);
+        }
+    };
+
+    void tes_context::read_from_stream(std::istream & stream) {
+
+        stream.flags(stream.flags() | std::ios::binary);
+
+#       if 0
+        std::ofstream file("dump", std::ios::binary | std::ios::out);
+        std::copy(
+            std::istreambuf_iterator<char>(stream),
+            std::istreambuf_iterator<char>(),
+            std::ostreambuf_iterator<char>(file)
+            );
+        file.close();
+#       endif
+
+        activity_stopper stopper{ *this };
+        {
+            // i have assumed that Skyrim devs are not idiots to run scripts in process of save game loading
+            //write_lock g(_mutex);
+
+            u_clearState();
+
+            if (stream.peek() != std::istream::traits_type::eof()) {
+
+                try {
+
+                    auto hdr = header::read_from_stream(stream);
+                    bool isNotSupported = serialization_version::current < hdr.commonVersion
+                        || hdr.commonVersion <= serialization_version::no_header;
+
+                    if (isNotSupported) {
+                        std::ostringstream error;
+                        error << "Unable to load serialized data of version " << (int)hdr.commonVersion
+                            << ". Current serialization version is " << (int)serialization_version::current;
+                        throw std::logic_error(error.str());
+                    }
+
+                    {
+                        hack::iarchive_with_blob real_archive(stream, *this, *this);
+                        boost::archive::binary_iarchive& archive = real_archive;
+
+                        if (hdr.commonVersion <= serialization_version::pre_dyn_form_watcher) {
+                            load_data_in_old_way(archive);
+                        } else {
+                            archive >> *this;
+                        }
+                    }
+
+                    u_postLoadInitializations();
+                    u_applyUpdates(hdr.commonVersion);
+                    u_postLoadMaintenance(hdr.commonVersion);
+                }
+                catch (const std::exception& exc) {
+                    _FATALERROR("caught exception (%s) during archive load - '%s'",
+                        typeid(exc).name(), exc.what());
+                    u_clearState();
+
+                    // force whole app to crash
+                   // jc_assert(false);
+                }
+                catch (...) {
+                    _FATALERROR("caught unknown (non std::*) exception");
+                    u_clearState();
+
+                    // force whole app to crash
+                    //jc_assert(false);
+                }
+            }
+
+            u_print_stats();
+        }
+    }
+
+    void tes_context::write_to_stream(std::ostream& stream) {
+
+        stream.flags(stream.flags() | std::ios::binary);
+
+        activity_stopper s{ *this };
+        {
+            // we can also cleanup objects here
+            {
+                _form_watcher.u_remove_expired_forms();
+            }
+
+            header::write_to_stream(stream);
+            boost::archive::binary_oarchive arch{ stream };
+            arch << *this;
+            u_print_stats();
+        }
+    }
+
+    namespace {
+        util::singleton<tes_context, false> g_tes_context_singleton {
+            []() { return new tes_context(); }
+        };
+    }
+
+    tes_context& tes_context::instance() {
+        return g_tes_context_singleton.get();
+    }
+
+    void tes_context::u_print_stats() const {
+        base::u_print_stats();
+        JC_log("%lu forms being observed", _form_watcher.u_forms_count());
+    }
+
+    void tes_context::read_from_string(const std::string & data) {
+        namespace io = boost::iostreams;
+        io::stream<io::array_source> stream(io::array_source(data.c_str(), data.size()));
+        read_from_stream(stream);
+    }
+
+    std::string tes_context::write_to_string() {
+        std::ostringstream stream;
+        write_to_stream(stream);
+        return stream.str();
+    }
+
+    template<class Archive> void tes_context::load_data_in_old_way(Archive& ar) {
+        base::load_data_in_old_way(ar);
+        boost::serialization::load_atomic(ar, _root_object_id);
+    }
+
+    template<class Archive> void tes_context::load(Archive & ar, unsigned int version) {
+        ar >> static_cast<base&>(*this);
+        boost::serialization::load_atomic(ar, _root_object_id);
+
+        if (version >= 1) {
+            ar >> _form_watcher;
+        }
+    }
+
+    template<class Archive> void tes_context::save(Archive & ar, unsigned int version) const {
+        ar << static_cast<const base&>(*this);
+        boost::serialization::save_atomic(ar, _root_object_id);
+        ar << _form_watcher;
+    }
+
+    ///////////////////////////
+
+    void tes_context::u_applyUpdates(const serialization_version saveVersion) {
+        if (saveVersion <= serialization_version::pre_gc) {
+            if (auto db = u_getObject(_root_object_id.load(std::memory_order_relaxed))) {
+                db->tes_retain();
+            }
+        }
+    }
+
+    ////////////////////////
+
+    void tes_context::shutdown() {
+        stop_activity();
+        u_clearState();
+    }
+
+    void tes_context::clearState() {
+        activity_stopper s{ *this };
+        u_clearState();
+    }
+
+    ////////////////////////////
+
+    void tes_context::set_root(object_base *db) {
+        object_base * prev = getObject(_root_object_id.load(std::memory_order_relaxed));
+
+        if (prev == db) {
+            return;
+        }
+
+        if (db) {
+            //db->retain();
+            db->tes_retain(); // emulates a user-who-needs @root, this will prevent @db from being garbage collected
+        }
+
+        if (prev) {
+            //prev->release();
+            prev->tes_release();
+        }
+
+        _root_object_id.store(db ? db->uid() : Handle::Null, std::memory_order_relaxed);
+    }
+
+    map& tes_context::root()
+    {
+        map * result = _cached_root.load(std::memory_order_acquire);
+        if (!result) {
+
+            spinlock::guard g(_lazyRootInitLock);
+
+            result = _cached_root.load(std::memory_order_relaxed);
+            if (!result) {
+                result = base::getObjectOfType<map>(_root_object_id.load(std::memory_order_relaxed));
+                if (!result) {
+                    result = &map::object(*this);
+                    set_root(result);
+                }
+
+                _cached_root.store(result, std::memory_order_release);
+            }
+        }
+
+        return *result;
+    }
+
+    //////////////////////////////////////////////////////////////////////////
+
+}
diff --git a/JContainers/src/collection_copying.h b/JContainers/src/collections/copying.h
similarity index 92%
rename from JContainers/src/collection_copying.h
rename to JContainers/src/collections/copying.h
index 4019749..71d7028 100644
--- a/JContainers/src/collection_copying.h
+++ b/JContainers/src/collections/copying.h
@@ -1,11 +1,11 @@
 #pragma once
 
 #include <set>
-#include "collections.h"
+#include "collections/collections.h"
 
 namespace collections {
 
-    class deep_copying {
+    class copying {
         // original - copy
         typedef std::map<const object_base *, object_base *> copyed_objects;
 
@@ -15,7 +15,7 @@ namespace collections {
         copyed_objects _copyed;
         object_to_traverse _to_traverse;
 
-        deep_copying(tes_context& context) : _context(context) {}
+        copying(tes_context& context) : _context(context) {}
 
         struct shallow_copy_helper {
             tes_context* _context;
@@ -32,7 +32,7 @@ namespace collections {
     public:
 
         static object_base& deep_copy(tes_context& context, const object_base & origin) {
-            return deep_copying(context)._deep_copy(origin);
+            return copying(context)._deep_copy(origin);
         }
 
         static object_base& shallow_copy(tes_context& context, const object_base& parent) {
@@ -72,7 +72,7 @@ namespace collections {
         }
 
         struct copy_child_objects {
-            deep_copying *const self;
+            copying *const self;
             void operator () (array& ar) {
                 object_lock lock(ar);
                 for (auto& itm : ar.u_container()) {
diff --git a/JContainers/src/tes_context.hpp b/JContainers/src/collections/default_value.h
similarity index 11%
rename from JContainers/src/tes_context.hpp
rename to JContainers/src/collections/default_value.h
index b740e2d..98eb0cd 100644
--- a/JContainers/src/tes_context.hpp
+++ b/JContainers/src/collections/default_value.h
@@ -1,5 +1,14 @@
+#pragma once
+
+#include "dyn_form_watcher.h"
 
 namespace collections {
 
+    template<class T> inline T default_value() {
+        return static_cast<T>(0);
+    };
 
+    template<> inline form_ref default_value<form_ref>() {
+        return form_ref{};
+    };
 }
diff --git a/JContainers/src/collections/dyn_form_watcher.h b/JContainers/src/collections/dyn_form_watcher.h
new file mode 100644
index 0000000..db55d3d
--- /dev/null
+++ b/JContainers/src/collections/dyn_form_watcher.h
@@ -0,0 +1,230 @@
+#pragma once
+
+//#include <hash_map>
+#include <concurrent_unordered_map.h>
+//#include <memory>
+#include <atomic>
+#include <tuple>
+#include <assert.h>
+#include "boost/shared_ptr.hpp"
+#include "boost/smart_ptr/weak_ptr.hpp"
+#include "boost/serialization/split_member.hpp"
+#include "boost/noncopyable.hpp"
+
+#include "util/spinlock.h"
+#include "util/stl_ext.h"
+
+#include "rw_mutex.h"
+#include "form_id.h"
+
+namespace collections {
+    
+namespace form_watching {
+
+    class form_observer;
+    class form_entry;
+
+    using form_entry_ref = boost::shared_ptr < form_entry > ;
+
+    class form_observer {
+    private:
+        using weak_entry = boost::weak_ptr<form_entry>;
+        using watched_forms_t = concurrency::concurrent_unordered_map < FormId, weak_entry >;
+
+        watched_forms_t _watched_forms;
+
+    public:
+
+        form_observer() = default;
+
+        void on_form_deleted(FormHandle fId);
+        form_entry_ref watch_form(FormId fId);
+
+        // Not threadsafe part of API:
+
+        void u_clearState() {
+            _watched_forms.clear();
+        }
+
+        size_t u_forms_count() const { return _watched_forms.size(); }
+        void u_remove_expired_forms();
+        void u_print_status() const;
+
+        /////////////////////////
+
+        friend class boost::serialization::access;
+        BOOST_SERIALIZATION_SPLIT_MEMBER();
+
+        template<class Archive> void save(Archive & ar, const unsigned int version) const;
+        template<class Archive> void load(Archive & ar, const unsigned int version);
+    };
+
+    class form_ref {
+        form_entry_ref _watched_form;
+
+    public:
+
+        explicit form_ref(form_entry_ref&& entry) : _watched_form(std::move(entry)) {}
+        explicit form_ref(const form_entry_ref& entry) : _watched_form(entry) {}
+
+        form_ref& operator = (form_ref&& entry) {
+            if (this != &entry) {
+                _watched_form = std::move(entry._watched_form);
+            }
+            return *this;
+        }
+
+        form_ref() = default;
+        form_ref& operator = (const form_ref &) = default;
+
+        form_ref(FormId id, form_observer& watcher);
+        form_ref(const TESForm& form, form_observer& watcher);
+
+        static form_ref make_expired(FormId formId);
+
+        // Special constructor - to load pre v3.3 data
+        enum load_old_id_t { load_old_id };
+        explicit form_ref(FormId oldId, form_observer& watcher, load_old_id_t);
+
+        bool is_not_expired() const;
+        bool is_expired() const { return !is_not_expired(); }
+
+        FormId get() const;
+        FormId get_raw() const;
+
+        bool operator!() const BOOST_NOEXCEPT { return is_expired(); }
+        BOOST_EXPLICIT_OPERATOR_BOOL_NOEXCEPT();
+
+        void swap(form_ref& other) {
+            static_assert(sizeof(other) == sizeof(_watched_form),
+                "ensures that no additional fields were added");
+            _watched_form.swap(other._watched_form);
+        }
+
+        // Implements stable 'less than' comparison
+        struct stable_less_comparer;
+
+        friend class boost::serialization::access;
+        BOOST_SERIALIZATION_SPLIT_MEMBER();
+
+        template<class Archive> void save(Archive & ar, const unsigned int version) const;
+        template<class Archive> void load(Archive & ar, const unsigned int version);
+    };
+
+    struct form_ref::stable_less_comparer {
+        template<class FormRef1, class FormRef2>
+        bool operator () (const FormRef1& left, const FormRef2& right) const {
+            return std::make_tuple(left.get_raw(), left.is_expired())
+                < std::make_tuple(right.get_raw(), right.is_expired());
+        }
+    };
+
+    // It's lightweight alternative to form_ref to temporarily hold forms
+    // why lightweight? form_ref constructor accesses form_observer, which is costly
+    class form_ref_lightweight {
+        FormId _formId = FormId::Zero;
+        form_observer* _observer = nullptr;
+
+    public:
+
+        form_ref_lightweight(FormId id, form_observer& watcher)
+            : _formId(id), _observer(&watcher) {}
+
+        // allow implicit conversion
+        form_ref_lightweight(const form_ref& ref)
+            : _formId(ref.get()) {}
+
+        form_ref_lightweight() = default;
+
+        form_ref to_form_ref() const {
+            return is_not_expired() ? (assert(_observer), form_ref(_formId, *_observer)) : form_ref();
+        }
+
+        // mimic form_ref interface
+        FormId get() const { return _formId; }
+        FormId get_raw() const { return _formId; }
+
+        bool operator!() BOOST_CONSTEXPR_OR_CONST BOOST_NOEXCEPT{ return is_expired(); }
+        BOOST_EXPLICIT_OPERATOR_BOOL_NOEXCEPT()
+
+        bool is_expired() BOOST_CONSTEXPR_OR_CONST{ return _formId == FormId::Zero; }
+        bool is_not_expired() BOOST_CONSTEXPR_OR_CONST{ return !is_expired(); }
+    };
+
+    // "Stupid" form_ref comparison functions:
+    // the functions don't care whether the @form_refs are really equal or not -
+    // really equal form_refs have equal @_watched_form fields
+    // The comparison is NOT stable
+    namespace comp {
+        template<class FormRef1, class FormRef2>
+        inline bool equal(const FormRef1& left, const FormRef2& right) {
+            return left.get() == right.get();
+        }
+        template<class FormRef1, class FormRef2>
+        inline bool less(const FormRef1& left, const FormRef2& right) {
+            return left.get() < right.get();
+        }
+    }
+
+    template<class FormRef>
+    inline bool operator == (const form_ref_lightweight& left, const FormRef& right) {
+        return comp::equal(left, right);
+    }
+
+    template<class FormRef>
+    inline bool operator == (const form_ref& left, const FormRef& right) {
+        return comp::equal(left, right);
+    }
+
+    template<class FormRef>
+    inline bool operator != (const form_ref_lightweight& left, const FormRef& right) {
+        return !comp::equal(left, right);
+    }
+
+    template<class FormRef>
+    inline bool operator != (const form_ref& left, const FormRef& right) {
+        return !comp::equal(left, right);
+    }
+
+    template<class FormRef>
+    inline bool operator < (const form_ref_lightweight& left, const FormRef& right) {
+        return comp::less(left, right);
+    }
+
+    template<class FormRef>
+    inline bool operator < (const form_ref& left, const FormRef& right) {
+        return comp::less(left, right);
+    }
+
+}
+
+    using form_watching::form_ref;
+    using form_watching::form_ref_lightweight;
+
+    template<class Context>
+    inline form_ref make_weak_form_id(FormId id, Context& context) {
+        return form_ref{ id, context._form_watcher };
+    }
+
+    template<class Context>
+    inline form_ref make_weak_form_id(const TESForm* form, Context& context) {
+        return form ? form_ref(*form, context._form_watcher) : form_ref();
+    }
+
+    template<class Context>
+    inline form_ref_lightweight make_lightweight_form_ref(FormId id, Context& context) {
+        return form_ref_lightweight{ id, context._form_watcher };
+    }
+
+    template<class Context>
+    inline form_ref_lightweight make_lightweight_form_ref(const TESForm* form, Context& context) {
+        return form_ref_lightweight{ form ? util::to_enum<FormId>(form->formID) : FormId::Zero, context._form_watcher };
+    }
+
+}
+
+namespace std {
+    template<> inline void swap(collections::form_watching::form_ref& left, collections::form_watching::form_ref& right) {
+        left.swap(right);
+    }
+}
diff --git a/JContainers/src/collections/dyn_form_watcher.hpp b/JContainers/src/collections/dyn_form_watcher.hpp
new file mode 100644
index 0000000..322fa45
--- /dev/null
+++ b/JContainers/src/collections/dyn_form_watcher.hpp
@@ -0,0 +1,557 @@
+#pragma once
+
+#include <boost/smart_ptr/make_shared_object.hpp>
+#include <boost/range.hpp>
+//#include <boost/algorithm/string/join.hpp>
+#include <assert.h>
+#include <inttypes.h>
+#include <map>
+#include <tuple>
+#include <mutex>
+
+//#include "skse/GameForms.h"
+//#include "skse/PapyrusVM.h"
+#include "skse/skse.h"
+#include "util/stl_ext.h"
+#include "util/util.h"
+
+#include "collections/form_handling.h"
+#include "collections/dyn_form_watcher.h"
+
+BOOST_CLASS_VERSION(collections::form_watching::form_ref, 2);
+BOOST_CLASS_VERSION(collections::form_watching::form_observer, 3);
+
+namespace collections {
+
+    namespace form_watching {
+
+        namespace fh = form_handling;
+
+        template<class ...Params>
+        inline void log(const char* fmt, Params&& ...ps) {
+            JC_log(fmt, std::forward<Params>(ps) ...);
+        }
+
+        class form_entry : public boost::noncopyable {
+
+            FormId _handle = FormId::Zero;
+            std::atomic<bool> _deleted = false;
+            // remember whether a form handle was retained or not
+            // to not release it if the handle wasn't be previously retained (for ex. handle's object was not loaded)
+            bool _is_handle_retained = false;
+
+        public:
+
+            form_entry(FormId handle, bool deleted, bool handle_was_retained)
+                : _handle(handle)
+                , _deleted(deleted)
+                , _is_handle_retained(handle_was_retained)
+            {}
+
+            form_entry() = default;
+
+            static form_entry_ref make(FormId handle) {
+                //log("form_entry retains %X", handle);
+
+                return boost::make_shared<form_entry>(
+                    handle,
+                    false,
+                    skse::try_retain_handle(handle));
+            }
+
+            static form_entry_ref make_expired(FormId handle) {
+                return boost::make_shared<form_entry>(handle, true, false);
+            }
+
+            ~form_entry() {
+                if (!u_is_deleted() && _is_handle_retained) {
+                    //log("form_entry releases %X", _handle);
+                    skse::release_handle(_handle);
+                }
+            }
+
+            FormId id() const { return _handle; }
+
+            bool is_deleted() const {
+                return _deleted.load(std::memory_order_acquire);
+            }
+
+            void set_deleted() {
+                _deleted.store(true, std::memory_order_release);
+            }
+
+            bool u_is_deleted() const {
+                return _deleted._My_val;
+            }
+            void u_set_deleted() {
+                _deleted._My_val = true;
+            }
+
+            friend class boost::serialization::access;
+            BOOST_SERIALIZATION_SPLIT_MEMBER();
+
+            template<class Archive> void save(Archive & ar, const unsigned int version) const {
+                ar << util::to_integral_ref(_handle);
+                ar << _deleted._My_val;
+            }
+
+            template<class Archive> void load(Archive & ar, const unsigned int version) {
+                ar >> util::to_integral_ref(_handle);
+                ar >> _deleted._My_val;
+
+                if (u_is_deleted() == false) {
+                    _handle = skse::resolve_handle(_handle);
+
+                    if (_handle != FormId::Zero) {
+                        _is_handle_retained = skse::try_retain_handle(_handle);
+                    }
+                    else {
+                        u_set_deleted();
+                    }
+                }
+            }
+        };
+
+        void form_observer::u_remove_expired_forms() {
+            auto hashmap_eraser = [](watched_forms_t& cnt, const watched_forms_t::const_iterator& itr) {
+                return cnt.unsafe_erase(itr);
+            };
+
+            util::tree_erase_if(_watched_forms, [](const watched_forms_t::value_type& pair) {
+                return pair.second.expired();
+            },
+                hashmap_eraser);
+        }
+
+        void form_observer::u_print_status() const
+        {
+            uint32_t count_of_one_user = 0;
+            uint32_t dyn_form_count = 0;
+
+            for (auto& pair : _watched_forms) {
+                if (!pair.second.expired()) {
+                    log("%" PRIX32 " : %u", pair.first, pair.second.use_count());
+                    if (pair.second.use_count() == 1) {
+                        ++count_of_one_user;
+                    }
+                    if (!fh::is_static(pair.first)) {
+                        ++dyn_form_count;
+                    }
+                }
+            }
+
+            log("total %u", _watched_forms.size());
+            log("count_of_one_user %u", count_of_one_user);
+            log("dyn_form_count %u", dyn_form_count);
+
+        }
+
+        namespace {
+
+            static boost::detail::spinlock & spinlock_for(FormId formId) {
+                using spinlock_pool = boost::detail::spinlock_pool < 'DyFW' > ;
+                return spinlock_pool::spinlock_for(reinterpret_cast<void*>(formId));
+            }
+        }
+
+        void form_observer::on_form_deleted(FormHandle handle)
+        {
+            // already failed, there are plenty of any kind of objects that are deleted every moment, even during initial splash screen
+            //jc_assert_msg(form_handling::is_static((FormId)handle) == false,
+                //"If failed, then there is static form destruction event too? fId %" PRIX64, handle);
+
+            if (!fh::is_form_handle(handle)) {
+                return;
+            }
+
+            // to test whether static form gets ever destroyed or not
+            //jc_assert(form_handling::is_static((FormId)handle) == false);
+
+            ///log("on_form_deleted: %" PRIX64, handle);
+
+            auto formId = fh::form_handle_to_id(handle);
+            {
+                // Since it's impossible that two threads will delete the same form simultaneosly
+                // we can skip some thread safe stuff
+                auto itr = _watched_forms.find(formId);
+                if (itr != _watched_forms.end()) {
+
+                    auto watched = itr->second.lock();
+
+                    if (watched) {
+                        watched->set_deleted();
+                        {
+                            // the only unsafe piece of code here
+                            std::lock_guard<boost::detail::spinlock> guard{ spinlock_for(formId) };
+                            itr->second.reset();
+                        }
+                        log("flagged form-entry %" PRIX32 " as deleted", formId);
+                    }
+                }
+            }
+        }
+
+        template<class Archive, class Collection, class ElementSaver>
+        void save_collection(Archive& archive, const Collection& collection, ElementSaver&& saver) {
+            uint32_t count = collection.size();
+            archive << count;
+            for (const auto& pair : collection) {
+                saver(archive, pair);
+            }
+        }
+        template<class Archive, class Collection, class ElementLoader>
+        void load_collection(Archive& archive, Collection& collection, ElementLoader&& loader) {
+            uint32_t count = 0;
+            archive >> count;
+
+            while (count > 0) {
+                --count;
+                loader(archive, collection);
+            }
+        }
+
+        template<class Archive>
+        void form_observer::load(Archive & ar, const unsigned int version) {
+
+            switch (version) {
+            case 3:
+                load_collection(ar, _watched_forms, [&ar](Archive& ar, decltype(_watched_forms)& collection) {
+                    form_entry_ref entry;
+                    ar >> entry;
+
+                    if (entry && !entry->is_deleted()) {
+                        collection[entry->id()] = std::move(entry);
+                    }
+                });
+                break;
+            case 2:{
+                std::hash_map<FormId, boost::weak_ptr<form_entry> > oldCnt;
+                ar >> oldCnt;
+
+                for (auto& pair : oldCnt) {
+                    form_entry_ref entry = pair.second.lock();
+                    if (entry && !entry->is_deleted()) {
+                        _watched_forms[entry->id()] = std::move(entry);
+                    }
+                }
+            }
+                break;
+            default:
+                jc_assert_msg(false, "Older versions of form_observer shouldn't be in release builds. In first place");
+                break;
+            }
+        }
+
+        template<class Archive>
+        void form_observer::save(Archive & ar, const unsigned int version) const {
+
+            save_collection(ar, _watched_forms, [&ar](Archive& ar, const decltype(_watched_forms)::value_type& pair) {
+                auto entry = pair.second.lock();
+                ar << entry;
+            });
+        }
+
+        form_entry_ref form_observer::watch_form(FormId fId)
+        {
+            if (fId == FormId::Zero) {
+                return nullptr;
+            }
+
+            {
+
+                auto itr = _watched_forms.find(fId);
+
+                std::lock_guard<boost::detail::spinlock> guard{ spinlock_for(fId) };
+
+                if (itr != _watched_forms.end()) {
+                    auto watched = itr->second.lock();
+                    if (!watched || watched->is_deleted()) {
+                        // form-entry and real form has been deleted (recently)
+                        // watch the form again, create entry, assuming that a new form with such ID exists
+
+                        // this code assumes that @watch_form tries to watch real existing form
+                        // rather than the one from JSON
+                        itr->second = watched = form_entry::make(fId);
+
+                        log("queried, re-created form-entry %" PRIX32, fId);
+                    }
+                    else {
+                        log("queried form-entry %" PRIX32, fId);
+                    }
+                    return watched;
+                }
+                else {
+                    auto watched = form_entry::make(fId);
+                    _watched_forms[fId] = watched;
+                    log("queried, created new form-entry %" PRIX32, fId);
+                    return watched;
+                }
+            }
+        }
+
+        struct lock_or_fail {
+            std::atomic_flag& flag;
+
+            explicit lock_or_fail(std::atomic_flag& flg) : flag(flg) {
+                jc_assert_msg(false == flg.test_and_set(std::memory_order_acquire),
+                    "My dyn_form_watcher test has failed? Report this please");
+            }
+
+            ~lock_or_fail() {
+                flag.clear(std::memory_order_release);
+            }
+        };
+
+        ////////////////////////////////////////
+
+        form_ref::form_ref(FormId id, form_observer& watcher)
+            : _watched_form(watcher.watch_form(id))
+        {
+        }
+
+        form_ref::form_ref(const TESForm& form, form_observer& watcher)
+            : _watched_form(watcher.watch_form(util::to_enum<FormId>(form.formID)))
+        {
+        }
+
+        form_ref::form_ref(FormId oldId, form_observer& watcher, load_old_id_t)
+            : _watched_form(watcher.watch_form(skse::resolve_handle(oldId)))
+        {
+        }
+
+        form_ref form_ref::make_expired(FormId formId) {
+            auto entry = form_entry::make_expired(formId);
+            return form_ref{ entry };
+        }
+
+        //////////////////
+
+        bool form_ref::is_not_expired() const {
+            return _watched_form && !_watched_form->is_deleted();
+        }
+
+        FormId form_ref::get() const {
+            return is_not_expired() ? _watched_form->id() : FormId::Zero;
+        }
+
+        FormId form_ref::get_raw() const {
+            return _watched_form ? _watched_form->id() : FormId::Zero;
+        }
+
+        template<class Archive>
+        void form_ref::save(Archive & ar, const unsigned int version) const
+        {
+            // optimization: if the form was deleted (is_not_expired is false) - write null instead
+
+            if (is_not_expired())
+                ar << _watched_form;
+            else {
+                decltype(_watched_form) fake;
+                ar << fake;
+            }
+        }
+
+        template<class Archive>
+        void form_ref::load(Archive & ar, const unsigned int version)
+        {
+
+            switch (version)
+            {
+            case 0: {// v3.3 alpha-1 format
+                FormId oldId = FormId::Zero;
+                ar >> oldId;
+                FormId id = skse::resolve_handle(oldId);
+                bool expired = false;
+                ar >> expired;
+
+                if (!expired) {
+                    auto& watcher = hack::iarchive_with_blob::from_base_get<tes_context>(ar)._form_watcher;
+                    _watched_form = watcher.watch_form(id);
+                }
+                break;
+            }
+            case 1: {
+                // Remove this case !!! This format wasn't ever published
+                FormId oldId = FormId::Zero;
+                ar >> oldId;
+                FormId id = skse::resolve_handle(oldId);
+                bool expired = false;
+                ar >> expired;
+
+                if (!expired) {
+                    ar >> _watched_form;
+                }
+                else {
+                    auto& watcher = hack::iarchive_with_blob::from_base_get<tes_context>(ar)._form_watcher;
+                    _watched_form = watcher.watch_form(id);
+                }
+                break;
+            }
+            case 2:
+                ar >> _watched_form;
+                break;
+            default:
+                assert(false);
+                break;
+            }
+        }
+
+        namespace tests {
+
+            namespace bs = boost;
+
+            TEST(form_entry_ref, _)
+            {
+                form_entry e;
+
+                e.set_deleted();
+                e.is_deleted();
+            }
+
+            TEST(form_watching, perft){
+
+                form_observer watcher;
+                util::do_with_timing("form_observer performance", [&](){
+
+
+                    for (int i = 0; i < 1000000; ++i) {
+                        watcher.watch_form(util::to_enum<FormId>(i % 1000));
+                    }
+
+                });
+            }
+
+
+            TEST(form_watching, simple){
+                form_ref id;
+
+                EXPECT_TRUE(!id);
+                EXPECT_TRUE(id.get() == FormId::Zero);
+                EXPECT_TRUE(id.get_raw() == FormId::Zero);
+            }
+
+            TEST(form_watching, simple_2){
+                const auto fid = util::to_enum<FormId>(0xff000014);
+                form_observer watcher;
+                form_ref id{ fid, watcher };
+
+                EXPECT_FALSE(!id);
+                EXPECT_TRUE(id.get() == fid);
+                EXPECT_TRUE(id.get_raw() == fid);
+
+                {
+                    form_ref copy = id;
+                    EXPECT_FALSE(!copy);
+                    EXPECT_TRUE(copy.get() == fid);
+                    EXPECT_TRUE(copy.get_raw() == fid);
+                }
+            }
+
+/*
+            TEST(form_observer, u_remove_expired_forms){
+                form_observer watcher;
+
+                const auto fid = util::to_enum<FormId>(0xff000014);
+
+                auto entry = watcher.watch_form(fid);
+                EXPECT_TRUE(watcher.u_forms_count() == 1);
+                EXPECT_NOT_NIL(entry.get());
+
+                watcher.on_form_deleted(fh::form_id_to_handle(fid));
+                watcher.u_remove_expired_forms();
+
+                EXPECT_TRUE(watcher.u_forms_count() == 0);
+                EXPECT_TRUE(entry->is_deleted());
+            }*/
+
+            TEST(form_watching, bug_1)
+            {
+                const auto fid = util::to_enum<FormId>(0x14);
+                form_observer watcher;
+                form_ref non_expired{ fid, watcher };
+
+                std::vector<form_ref> forms = { form_ref::make_expired(fid) };
+
+                EXPECT_FALSE(std::find(forms.begin(), forms.end(), non_expired) != forms.end()); // had to be EXPECT_FALSE
+            }
+
+            template<class T, class V>
+            bool contains(T&& cnt, V&& value) {
+                return cnt.find(value) != cnt.end();
+            }
+
+            // 
+            TEST(form_watching, bug_2)
+            {
+                const auto fid = util::to_enum<FormId>(0x14);
+                form_observer watcher;
+                form_ref non_expired{ fid, watcher };
+
+                std::map<form_ref, int> forms = { { form_ref::make_expired(fid), 0 } };
+
+                EXPECT_FALSE( contains(forms, non_expired) ); // had to be EXPECT_FALSE
+            }
+
+            TEST(form_watching, bug_3)
+            {
+                const auto fid = util::to_enum<FormId>(0x14);
+                form_observer watcher;
+                form_ref non_expired{ fid, watcher };
+                auto expired = form_ref::make_expired(fid);
+
+                std::map<form_ref, int> forms = { { non_expired, 0 } };
+
+                EXPECT_FALSE(contains(forms, expired)); // had to be EXPECT_FALSE
+            }
+
+            TEST(form_watching, bug_4)
+            {
+                const auto fid = util::to_enum<FormId>(0xff000014);
+                const auto fhid = fh::form_id_to_handle(fid);
+
+                form_observer watcher;
+
+                std::map<form_ref, int> forms = { { form_ref{ fid, watcher }, 0 } };
+                watcher.on_form_deleted(fhid);
+
+                EXPECT_TRUE(forms.begin()->first.is_expired());
+
+                forms[form_ref{ fid, watcher }] = 0;
+
+                EXPECT_TRUE(forms.size() == 2);
+                // one of the keys should be non-expired
+                EXPECT_TRUE(forms.begin()->first.is_not_expired() != (++forms.begin())->first.is_not_expired());
+            }
+
+            TEST(form_watching, dynamic_form_id){
+                const auto fid = util::to_enum<FormId>(0xff000014);
+                const auto fhid = fh::form_id_to_handle(fid);
+               // EXPECT_TRUE(fh::is_static(fid) == false);
+
+                form_observer watcher;
+                form_ref id{ fid, watcher };
+                form_ref id2{ fid, watcher };
+
+                auto expectNotExpired = [&](const form_ref& id) {
+                    EXPECT_TRUE(id.is_not_expired());
+                    EXPECT_TRUE(id.get() == fid);
+                };
+
+                auto expectExpired = [&](const form_ref& id) {
+                    EXPECT_FALSE(id.is_not_expired());
+                    EXPECT_TRUE(id.get() == FormId::Zero);
+                    EXPECT_TRUE(id.get_raw() == fid);
+                };
+
+                expectNotExpired(id);
+                expectNotExpired(id2);
+
+                watcher.on_form_deleted(fhid);
+
+                expectExpired(id);
+                expectExpired(id2);
+            }
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/JContainers/src/tes_error_code.h b/JContainers/src/collections/error_code.h
similarity index 100%
rename from JContainers/src/tes_error_code.h
rename to JContainers/src/collections/error_code.h
diff --git a/JContainers/src/form_handling.h b/JContainers/src/collections/form_handling.h
similarity index 46%
rename from JContainers/src/form_handling.h
rename to JContainers/src/collections/form_handling.h
index 3ca41b6..2239264 100644
--- a/JContainers/src/form_handling.h
+++ b/JContainers/src/collections/form_handling.h
@@ -6,17 +6,14 @@
 #include <boost/optional.hpp>
 #include "boost_extras.h"
 
-#include "skse.h"
+#include "skse/skse.h"
 
 namespace collections {
 
     namespace form_handling {
 
-        static const char * kFormData = "__formData";
-        static const char * kFormDataSeparator = "|";
-
         inline uint8_t mod_index(FormId formId) {
-            return formId >> 24;
+            return (uint32_t)formId >> 24;
         }
 
         inline bool is_static(FormId formId) {
@@ -24,33 +21,39 @@ namespace collections {
         }
 
         inline uint32_t local_id(FormId formId) {
-            return formId & 0x00FFFFFF;
+            return (uint32_t)formId & 0x00FFFFFF;
+        }
+
+        inline bool is_form_handle(FormHandle handle) {
+            return ((uint64_t)handle >> 32) == 0x0000FFFF;
+        }
+
+        inline FormId form_handle_to_id(FormHandle handle) {
+            return static_cast<FormId>(handle);
+        }
+
+        inline FormHandle form_id_to_handle(FormId id) {
+            return (FormHandle)(0x0000ffff00000000 | (uint64_t)id);
         }
 
         inline FormId construct(uint8_t mod_id, uint32_t local_identifier) {
             return (FormId) ((mod_id << 24) | local_id((FormId)local_identifier));
         }
 
-        inline FormId resolve_handle(FormId handle) {
-            if (is_static(handle)) {
-                return (FormId)skse::resolve_handle((uint32_t)handle);
-            }
-            else {
-                return skse::lookup_form((uint32_t)handle) ? handle : FormZero;
-            }
-        }
+        static const char kFormData[] = "__formData";
+        static const char * kFormDataSeparator = "|";
 
         inline boost::optional<std::string> to_string(FormId formId) {
 
             auto modID = mod_index(formId);
-            uint32_t formIdClean = formId;
+            uint32_t formIdClean = (uint32_t)formId;
 
             const char * modName = nullptr;
 
             if (is_static(formId)) { // common case
                 modName = skse::modname_from_index (modID);
                 if (!modName) {
-                    return false;
+                    return boost::none;
                 }
 
                 formIdClean = local_id(formId);
@@ -60,20 +63,14 @@ namespace collections {
                 modName = "";
             }
 
-            std::string string = kFormData;
-            string += kFormDataSeparator;
-            string += modName;
-            string += kFormDataSeparator;
+            char string[MAX_PATH] = { '\0' };
+            assert(-1 != _snprintf_s(string, sizeof string, "__formData|%s|0x%x", modName, formIdClean));
 
-            char buff[20] = {'\0'};
-            sprintf(buff, "0x%x", formIdClean);
-            string += buff;
-
-            return string;
+            return boost::optional<std::string>{ string };
         }
 
         inline bool is_form_string(const char *string) {
-            return string && strncmp(string, kFormData, strlen(kFormData)) == 0;
+            return string && strncmp(string, kFormData, sizeof kFormData - 1) == 0;
         }
 
         // TODO: rename me!
@@ -81,25 +78,29 @@ namespace collections {
             namespace bs = boost;
             namespace ss = std;
 
-            auto pair1 = bs::half_split(fstring, "|");
+            auto pair1 = bs::half_split(fstring, kFormDataSeparator);
 
             if (pair1.second.empty() || !std::equal(pair1.first.begin(), pair1.first.end(), kFormData)) {
-                return boost::optional<FormId>(false, FormZero);
+                return boost::optional<FormId>(false, FormId::Zero);
             }
 
-            auto pair2 = bs::half_split(pair1.second, "|");
+            auto pair2 = bs::half_split(pair1.second, kFormDataSeparator);
             // pair2.first - modname part can be empty
             if (/*pair2.first.empty() || */pair2.second.empty()) {
-                return boost::optional<FormId>(false, FormZero);
+                return boost::optional<FormId>(false, FormId::Zero);
             }
             
             auto& pluginName = pair2.first;
 
             UInt8 modIdx = 0;
             if (!pluginName.empty()) {
-                modIdx = skse::modindex_from_name( ss::string(pluginName.begin(), pluginName.end()).c_str() );
+                char *long_string = (char*)_malloca(pluginName.size() + 1);
+                auto res = strncpy_s(long_string, pluginName.size() + 1, pluginName.begin(), pluginName.size());
+                assert(0 == res);
+
+                modIdx = skse::modindex_from_name(long_string);
                 if (modIdx == FormGlobalPrefix) {
-                    return boost::optional<FormId>(false, FormZero);
+                    return boost::none;
                 }
             }
             else {
@@ -109,19 +110,31 @@ namespace collections {
 
             auto& formIdString = pair2.second;
 
-            uint32_t formId = 0;
-            try {
-                formId = std::stoul(ss::string(formIdString.begin(), formIdString.end()), nullptr, 0);
-            }
-            catch (const std::invalid_argument& ) {
-                return boost::optional<FormId>(false, FormZero);
-            }
-            catch (const std::out_of_range& ) {
-                return boost::optional<FormId>(false, FormZero);
+            auto stoul_optimized = [](boost::iterator_range<const char*>& str, size_t *_Idx, int _Base) -> bs::optional<unsigned long> {	// convert string to unsigned long
+                char *long_string = (char*)_malloca(str.size() + 1);
+                auto res = strncpy_s(long_string, str.size() + 1, str.begin(), str.size());
+                assert(0 == res);
+
+                const char *_Ptr = long_string;
+                char *_Eptr;
+                errno = 0;
+                unsigned long _Ans = _CSTD strtoul(_Ptr, &_Eptr, _Base);
+
+                if (_Ptr == _Eptr)
+                    return boost::none; //_Xinvalid_argument("invalid stoul argument");
+                if (errno == ERANGE)
+                    return boost::none; //_Xout_of_range("stoul argument out of range");
+                if (_Idx != 0)
+                    *_Idx = (size_t)(_Eptr - _Ptr);
+                return (_Ans);
+            };
+
+            bs::optional<unsigned long> optFormId = stoul_optimized(formIdString, nullptr, 0);
+            if (optFormId) {
+                return construct(modIdx, *optFormId);
             }
 
-            formId = construct(modIdx, formId);
-            return (FormId)formId;
+            return boost::none;
         }
 
         inline boost::optional<FormId> from_string(const char* source) {
diff --git a/JContainers/src/collection_functions.h b/JContainers/src/collections/functions.h
similarity index 76%
rename from JContainers/src/collection_functions.h
rename to JContainers/src/collections/functions.h
index e4a1894..bba40e6 100644
--- a/JContainers/src/collection_functions.h
+++ b/JContainers/src/collections/functions.h
@@ -3,7 +3,7 @@
 #include <array>
 #include <boost/optional.hpp>
 
-#include "collections.h"
+#include "collections/collections.h"
 
 namespace collections {
 
@@ -13,14 +13,17 @@ namespace collections {
         typedef int32_t index;
         typedef boost::optional<index> maybe_index;
 
-        static maybe_index convertReadIndex(const object_base *ar, index pyIndex) {
-            auto count = ar->u_count();
+        static maybe_index convertReadIndex(int32_t count, index pyIndex) {
             index index = (pyIndex >= 0 ? pyIndex : (count + pyIndex));
 
             return maybe_index(count > 0 && index < count,
                 index);
         }
 
+        static maybe_index convertReadIndex(const object_base *ar, index pyIndex) {
+            return convertReadIndex(ar->u_count(), pyIndex);
+        }
+
         static maybe_index convertWriteIndex(const object_base *ar, index pyIndex) {
             auto count = ar->u_count();
             index index = (pyIndex >= 0 ? pyIndex : (count + pyIndex + 1));
@@ -94,7 +97,9 @@ namespace collections {
         static bool check(const std::string& s)  { return !s.empty(); }
         static bool check(const char *s)  { return s != nullptr && *s; }
         static bool check(TESForm *f)  { return f != nullptr; }
-        static bool check(FormId f)  { return f != FormZero; }
+        static bool check(FormId f)  { return f != FormId::Zero; }
+        static bool check(const form_ref& f)  { return f.is_not_expired(); }
+        static bool check(const form_ref_lightweight& f)  { return f.is_not_expired(); }
         static bool check(int32_t)  { return true; }
     };
 
@@ -132,7 +137,7 @@ namespace collections {
         static void doWriteOp(T * obj, const key_type& key, Op& operation) {
             if (obj && key_checker::check(key)) {
                 object_lock g(obj);
-                item &itm = obj->u_container()[key];
+                item &itm = obj->u_get_or_create(key);
                 operation(itm);
             }
         }
@@ -155,6 +160,47 @@ namespace collections {
             }
         }
 
+        struct equal_to {
+            template<class T, class D>
+            inline bool operator()(T& t, D& d) const {
+                return t == d;
+            }
+        };
+
+        template<class KeyTypeIn, class KeyComparer = equal_to>
+        static KeyTypeIn nextKey_forPapyrus(const T *obj, const KeyTypeIn& lastKey,
+            const KeyTypeIn& endKey, const KeyComparer key_equality = equal_to{})
+        {
+            if (obj) {
+                object_lock g(obj);
+                auto& container = obj->u_container();
+
+                if (container.empty()) {
+                    return endKey;
+                }
+                else if (lastKey != endKey) {
+                    auto itr = obj->u_find_iterator(lastKey);
+                    const auto end = container.cend();
+
+                    if (itr == end) {
+                        return endKey;
+                    }
+
+                    while (++itr != end) {
+                        if (key_equality(itr->first, endKey) == false) {
+                            return itr->first;
+                        }
+                    }
+                }
+                // start iteration
+                else {
+                    return container.begin()->first;
+                }
+            }
+
+            return endKey;
+        }
+
         template<class KeyFunc>
         static void getNthKey(const T *obj, int32_t keyIdx, KeyFunc keyFunc) {
             if (obj) {
diff --git a/JContainers/src/collection_item.h b/JContainers/src/collections/item.h
similarity index 79%
rename from JContainers/src/collection_item.h
rename to JContainers/src/collections/item.h
index 43f3979..861061c 100644
--- a/JContainers/src/collection_item.h
+++ b/JContainers/src/collections/item.h
@@ -2,14 +2,17 @@
 
 #include <boost/variant.hpp>
 #include <string>
+#include <xutility>
 
 #include "common/ITypes.h"
 #include "object/object_base.h"
-#include "skse.h"
-#include "skse_string.h"
+#include "skse/skse.h"
+#include "skse/string.h"
+
+#include "form_id.h"
+#include "collections/collections.h"
+#include "collections/dyn_form_watcher.h"
 
-#include "collections.h"
-#include "collection_types.h"
 
 namespace collections {
 
@@ -27,7 +30,7 @@ namespace collections {
     public:
         typedef boost::blank blank;
         typedef Float32 Real;
-        typedef boost::variant<boost::blank, SInt32, Real, FormId, internal_object_ref, std::string> variant;
+        typedef boost::variant<boost::blank, SInt32, Real, form_ref, internal_object_ref, std::string> variant;
 
     private:
         variant _var;
@@ -39,7 +42,7 @@ namespace collections {
         template<> struct type2index < boost::blank >  { static const item_type index = none; };
         template<> struct type2index < SInt32 >  { static const item_type index = integer; };
         template<> struct type2index < Real >  { static const item_type index = real; };
-        template<> struct type2index < FormId >  { static const item_type index = form; };
+        template<> struct type2index < form_ref >  { static const item_type index = form; };
         template<> struct type2index < internal_object_ref >  { static const item_type index = object; };
         template<> struct type2index < std::string >  { static const item_type index = string; };
 
@@ -53,17 +56,16 @@ namespace collections {
             }
         }
 
-        item() {}
+        item() = default;
+        item(const item& other) = default;
+        item& operator = (const item& other) = default;
+
         item(item&& other) : _var(std::move(other._var)) {}
-        item(const item& other) : _var(other._var) {}
 
         item& operator = (item&& other) {
-            _var = std::move(other._var);
-            return *this;
-        }
-
-        item& operator = (const item& other) {
-            _var = other._var;
+            if (this != &other) {
+                _var = std::move(other._var);
+            }
             return *this;
         }
 
@@ -80,7 +82,7 @@ namespace collections {
         }
 
         item_type type() const {
-            return item_type(_var.which() + 1);
+            return item_type(_var.which() + item_type::none);
         }
 
         template<class T> T* get() {
@@ -109,16 +111,15 @@ namespace collections {
         explicit item(SInt32 val) : _var(val) {}
         explicit item(int val) : _var((SInt32)val) {}
         explicit item(bool val) : _var((SInt32)val) {}
-        explicit item(FormId id) : _var(id) {}
+        explicit item(const form_ref& id) : _var(id) {}
+        explicit item(form_ref&& id) : _var(std::move(id)) {}
+
         explicit item(object_base& o) : _var(o) {}
 
         explicit item(const std::string& val) : _var(val) {}
-        explicit item(std::string&& val) : _var(val) {}
+        explicit item(std::string&& val) : _var(std::move(val)) {}
 
         // the Item is none if the pointers below are zero:
-        explicit item(const TESForm *val) {
-            *this = val;
-        }
         explicit item(const char * val) {
             *this = val;
         }
@@ -131,10 +132,6 @@ namespace collections {
         explicit item(const object_stack_ref &val) {
             *this = val.get();
         }
-        /*
-        explicit Item(const BSFixedString& val) : _var(boost::blank()) {
-        *this = val.data;
-        }*/
 
         item& operator = (unsigned int val) { _var = (SInt32)val; return *this; }
         item& operator = (int val) { _var = (SInt32)val; return *this; }
@@ -148,18 +145,6 @@ namespace collections {
         item& operator = (boost::none_t) { _var = boost::blank(); return *this; }
         item& operator = (object_base& v) { _var = &v; return *this; }
 
-
-        item& operator = (FormId formId) {
-            // prevent zero FormId from being saved
-            if (formId) {
-                _var = formId;
-            }
-            else {
-                _var = blank();
-            }
-            return *this;
-        }
-
         template<class T>
         item& _assignPtr(T *ptr) {
             if (ptr) {
@@ -171,6 +156,11 @@ namespace collections {
             return *this;
         }
 
+        item& operator = (const form_ref& val) {
+            _var = val;
+            return *this;
+        }
+
         item& operator = (const char *val) {
             return _assignPtr(val);
         }
@@ -179,16 +169,6 @@ namespace collections {
             return _assignPtr(val);
         }
 
-        item& operator = (const TESForm *val) {
-            if (val) {
-                _var = (FormId)val->formID;
-            }
-            else {
-                _var = blank();
-            }
-            return *this;
-        }
-
         object_base *object() const {
             if (auto ref = boost::get<internal_object_ref>(&_var)) {
                 return ref->get();
@@ -203,7 +183,7 @@ namespace collections {
             else if (auto val = boost::get<SInt32>(&_var)) {
                 return *val;
             }
-            return 0;
+            return 0.f;
         }
 
         SInt32 intValue() const {
@@ -213,6 +193,10 @@ namespace collections {
             else if (auto val = boost::get<item::Real>(&_var)) {
                 return *val;
             }
+            // ability to read forms as integer values. likely not needed anymore
+            /*else if (auto val = boost::get<form_ref>(&_var)) {
+                return static_cast<SInt32>(val->get_raw());
+            }*/
             return 0;
         }
 
@@ -223,20 +207,15 @@ namespace collections {
             return nullptr;
         }
 
-        std::string * stringValue() {
-            return boost::get<std::string>(&_var);
-        }
-
         TESForm * form() const {
-            auto frmId = formId();
-            return frmId != FormZero ? skse::lookup_form(frmId) : nullptr;
+            return skse::lookup_form(formId());
         }
 
         FormId formId() const {
-            if (auto val = boost::get<FormId>(&_var)) {
-                return *val;
+            if (auto val = boost::get<form_ref>(&_var)) {
+                return val->get();
             }
-            return FormZero;
+            return FormId::Zero;
         }
 
         class are_strict_equals : public boost::static_visitor<bool> {
@@ -269,12 +248,12 @@ namespace collections {
             return is_type<SInt32>() || is_type<Real>();
         }
 
-        template<class T> T readAs();
+        template<class T> T readAs() const;
 
         //////////////////////////////////////////////////////////////////////////
     private:
         static_assert(std::is_same<
-            boost::variant<boost::blank, SInt32, Real, FormId, internal_object_ref, std::string>,
+            boost::variant<boost::blank, SInt32, Real, form_ref, internal_object_ref, std::string>,
             variant
         >::value, "update _user2variant code below");
 
@@ -337,38 +316,56 @@ namespace collections {
 
     };
 
-    template<> inline item::Real item::readAs<item::Real>() {
+    template<> inline item::Real item::readAs<item::Real>() const {
         return fltValue();
     }
 
-    template<> inline SInt32 item::readAs<SInt32>() {
+    template<> inline SInt32 item::readAs<SInt32>() const {
         return intValue();
     }
 
-    template<> inline const char * item::readAs<const char *>() {
+    template<> inline const char * item::readAs<const char *>() const {
         return strValue();
     }
 
-    template<> inline std::string item::readAs<std::string>() {
-        auto str = stringValue();
+    template<> inline std::string item::readAs<std::string>() const {
+        auto str = boost::get<std::string>(&_var);
         return str ? *str : std::string();
     }
 
-    template<> inline skse::string_ref item::readAs<skse::string_ref>() {
+    template<> inline skse::string_ref item::readAs<skse::string_ref>() const {
         const char *chr = strValue();
         return chr ? skse::string_ref(chr) : skse::string_ref();
     }
 
-    template<> inline Handle item::readAs<Handle>() {
+    template<> inline Handle item::readAs<Handle>() const {
         auto obj = object();
-        return obj ? obj->uid() : HandleNull;
+        return obj ? obj->uid() : Handle::Null;
     }
 
-    template<> inline TESForm * item::readAs<TESForm*>() {
+    template<> inline TESForm * item::readAs<TESForm*>() const {
         return form();
     }
 
-    template<> inline object_base * item::readAs<object_base*>() {
+    template<> inline object_base * item::readAs<object_base*>() const {
         return object();
     }
-}
\ No newline at end of file
+
+    template<> inline FormId item::readAs<FormId>() const {
+        return formId();
+    }
+
+    template<> inline form_ref item::readAs<form_ref>() const {
+        auto form_ptr = get<form_ref>();
+        return form_ptr ? *form_ptr : form_ref{};
+    }
+
+}
+
+namespace std {
+    template<> inline void swap(collections::item& l, collections::item& r) {
+        static_assert(sizeof(decltype(l)) == sizeof(decltype(l.var())),
+            "ensures that no additional fields were added");
+        l.var().swap(r.var());
+    }
+}
diff --git a/JContainers/src/json_handling.h b/JContainers/src/collections/json_serialization.h
similarity index 91%
rename from JContainers/src/json_handling.h
rename to JContainers/src/collections/json_serialization.h
index 1741f7d..a9a23db 100644
--- a/JContainers/src/json_handling.h
+++ b/JContainers/src/collections/json_serialization.h
@@ -6,10 +6,10 @@
 #include <jansson.h>
 #include <memory>
 
-#include "collections.h"
-#include "form_handling.h"
+#include "collections/collections.h"
+#include "collections/form_handling.h"
 #include "boost_extras.h"
-#include "path_resolving.h"
+#include "collections/access.h"
 #include "boost/filesystem/path.hpp"
 
 namespace collections {
@@ -85,8 +85,15 @@ namespace collections {
     public:
 
         static json_unique_ref json_from_file(const char *path) {
-            json_error_t error; //  TODO: output error
-            json_ref ref = json_load_file(path, 0, &error);
+            json_ref ref = nullptr;
+            if (path) {
+                json_error_t error; //  TODO: output error
+                auto file = make_unique_ptr(fopen(path, "rb"), fclose);
+                auto cb = [](void *buffer, size_t buflen, void *data) -> size_t {
+                    return data ? fread(buffer, 1, buflen, reinterpret_cast<FILE*>(data)) : 0;
+                };
+                ref = json_load_callback(cb, file.get(), 0, &error);
+            }
             return make_unique_ptr(ref, json_decref);
         }
 
@@ -146,11 +153,14 @@ namespace collections {
                 auto& path = pair.first;
                 object_base *resolvedObject = nullptr;
 
-                path_resolving::resolve(_context, &root, path.c_str(), [&resolvedObject](item *itm) {
-                    if (itm) {
-                        resolvedObject = itm->object();
-                    }
-                });
+                if (path.empty() == false) {
+                    ca::visit_value(root, path.c_str(), ca::constant, [&resolvedObject](item& itm) {
+                        resolvedObject = itm.object();
+                    });
+                }
+                else { // special case "__reference|"
+                    resolvedObject = &root;
+                }
 
                 if (!resolvedObject) {
                     continue;
@@ -189,7 +199,8 @@ namespace collections {
                     json_object_foreach(val, key, value) {
                         auto fkey = form_handling::from_string(key);
                         if (fkey) {
-                            cnt.u_set(*fkey, self->make_item(value, cnt, *fkey));
+                            form_ref weak_key = make_weak_form_id(*fkey, self->_context);
+                            cnt.u_set(weak_key, self->make_item(value, cnt, weak_key));
                         }
                     }
                 }
@@ -287,16 +298,16 @@ namespace collections {
                 } else {
                     if (form_handling::is_form_string(string)) {
                         /*  having dilemma here:
-                            if string looks like form-string and plugin name can't be resolved:
+                            if the string looks like form-string and plugin name can't be resolved:
                             a. lost info and convert it to FormZero
                             b. save info and convert it to string
                         */
-                        item = form_handling::from_string(string).get_value_or(FormZero);
+                        item = make_weak_form_id(form_handling::from_string(string).get_value_or(FormId::Zero), _context);
                     }
                     else if (schedule_ref_resolving(string, container, item_key)) { // otherwise it's reference string?
                         ;
                     }
-                    else {  // otherwise it's just a string, althought it starts with "__"
+                    else {  // otherwise it's just a string, although it starts with "__"
                         item = string;
                     }
                 }
@@ -333,7 +344,7 @@ namespace collections {
         objects_to_fill _toFill;
 
         // contained - <container, key> relationship
-        typedef boost::variant<int32_t, std::string, FormId> key_variant;
+        typedef boost::variant<int32_t, std::string, form_ref> key_variant;
         typedef std::map<const object_base*, std::pair<const object_base*, key_variant > > key_info_map;
         key_info_map _keyInfo;
 
@@ -414,7 +425,7 @@ namespace collections {
                     json_object_serialization_consts::put_metainfo<form_map>(object);
 
                     for (auto& pair : cnt.u_container()) {
-                        auto key = form_handling::to_string(pair.first);
+                        auto key = form_handling::to_string(pair.first.get());
                         if (key) {
                             self->fill_key_info(pair.second, cnt, pair.first);
                             json_object_set_new(object, (*key).c_str(), self->create_value(pair.second));
@@ -476,8 +487,8 @@ namespace collections {
                     return json_real(val);
                 }
 
-                json_ref operator()(const FormId&  val) const {
-                    auto formStr = form_handling::to_string(val);
+                json_ref operator()(const form_ref& val) const {
+                    auto formStr = form_handling::to_string(val.get());
                     if (formStr) {
                         return (*this)(*formStr);
                     }
@@ -513,7 +524,7 @@ namespace collections {
 
         std::string path_to_object(const object_base& obj) const {
 
-            std::string path;
+            std::string path{ reference_serialization::prefix };
 
             struct path_appender : boost::static_visitor<> {
                 std::string& p;
@@ -531,9 +542,9 @@ namespace collections {
                     p.append(data);
                 }
 
-                void operator()(const FormId& fid) const {
+                void operator()(const form_ref& fid) const {
                     p.append("[");
-                    p.append(*form_handling::to_string(fid));
+                    p.append(*form_handling::to_string(fid.get()));
                     p.append("]");
                 }
 
@@ -556,8 +567,6 @@ namespace collections {
                 }
             }
 
-            path.append(reference_serialization::prefix);
-
             for (auto& key_var : keys) {
                 boost::apply_visitor(path_appender, *key_var);
             }
diff --git a/JContainers/src/lua_module.cpp b/JContainers/src/collections/lua_module.cpp
similarity index 73%
rename from JContainers/src/lua_module.cpp
rename to JContainers/src/collections/lua_module.cpp
index 1e388c1..7b704a1 100644
--- a/JContainers/src/lua_module.cpp
+++ b/JContainers/src/collections/lua_module.cpp
@@ -2,7 +2,7 @@
 #include "lua_module.h"
 
 #include <boost/noncopyable.hpp>
-#include <boost/thread/tss.hpp>
+//#include <boost/thread/tss.hpp>
 #include <boost/optional.hpp>
 #include <boost/filesystem/path.hpp>
 #include <boost/lockfree/queue.hpp>
@@ -24,13 +24,13 @@ extern "C" {
 #include "util/util.h"
 #include "gtest.h"
 #include "util/spinlock.h"
-
-#include "reflection.h"
+#include "reflection/reflection.h"
 #include "jcontainers_constants.h"
-#include "collections.h"
-#include "tes_context.h"
-#include "collection_functions.h"
-#include "path_resolving.h"
+
+#include "collections/collections.h"
+#include "collections/context.h"
+#include "collections/functions.h"
+#include "collections/access.h"
 
 // Module imports:
 
@@ -42,6 +42,8 @@ namespace lua {
     using item = collections::item;
     using item_type = collections::item_type;
     using FormId = collections::FormId;
+
+    namespace cl = collections;
 }
 
 #include "lua_native_funcs.hpp"
@@ -56,60 +58,60 @@ namespace lua { namespace aux_wip {
 
     class context : public boost::noncopyable {
 
-        lua_State *l = nullptr;
-        tes_context& tcontext;
+        lua_State *_lua = nullptr;
+        tes_context& _context;
 
     public:
 
         lua_State *state() const {
-            return l;
+            return _lua;
         }
 
-        explicit context(tes_context& context) : tcontext(context) {
+        explicit context(tes_context& context) : _context(context) {
             reopen_if_closed();
-            _DMESSAGE("Lua context created");
+            JC_log("Lua context created");
         }
 
         ~context() {
             close();
-            _DMESSAGE("Lua context destructed");
+            JC_log("Lua context destructed");
         }
 
         boost::optional<item> eval_lua_function(object_base *object, const char *lua_string) {
 
             assert(lua_string);
 
-            lua_pushcfunction(l, LuaErrorHandler);
-            int errorHandler = lua_gettop(l);
+            lua_pushcfunction(_lua, LuaErrorHandler);
+            int errorHandler = lua_gettop(_lua);
 
-            lua_getglobal(l, "JC_compileAndRun");
-            lua_pushstring(l, lua_string);
-            lua_pushlightuserdata(l, object);
+            lua_getglobal(_lua, "JC_compileAndRun");
+            lua_pushstring(_lua, lua_string);
+            lua_pushlightuserdata(_lua, object);
             enum { num_args = 2, returned = 1 };
 
-            if (lua_pcall(l, num_args, returned, errorHandler) != LUA_OK) {
+            if (lua_pcall(_lua, num_args, returned, errorHandler) != LUA_OK) {
                 return boost::none;
             }
             else {
                 item result;
-                JCValue *val = (JCValue *)lua_topointer(l, -1);
-                JCValue_fillItem(val, result);
+                JCValue *val = (JCValue *)lua_topointer(_lua, -1);
+                JCValue_fillItem(_context, val, result);
                 return result;
             }
         }
 
         void reopen_if_closed() {
-            if (!l) {
-                l = luaL_newstate();
-                luaL_openlibs(l);
-                setupLuaContext(l, tcontext);
+            if (!_lua) {
+                _lua = luaL_newstate();
+                luaL_openlibs(_lua);
+                setupLuaContext(_lua, _context);
             }
         }
 
         void close() {
-            if (l) {
-                auto lua = l;
-                l = nullptr;
+            if (_lua) {
+                auto lua = _lua;
+                _lua = nullptr;
                 lua_close(lua);
             }
         }
@@ -124,8 +126,7 @@ namespace lua { namespace aux_wip {
         }
 
         static void print_top_string(lua_State *l, const char* preambula) {
-            _MESSAGE("%s: %s", preambula, top_string(l));
-            //skse::console_print(str);
+            JC_log("Lua %s: %s", preambula, top_string(l));
         }
 
         static bool setupLuaContext(lua_State *l, tes_context& context) {
@@ -137,7 +138,7 @@ namespace lua { namespace aux_wip {
             int errorHandler = lua_gettop(l);
 
             if (luaL_loadfile(l, initScriptPath.generic_string().c_str()) != LUA_OK) {
-                print_top_string(l, "Lua unable to load init.lua and etc");
+                print_top_string(l, "unable to load init.lua and etc");
                 return false;
             }
 
@@ -148,7 +149,7 @@ namespace lua { namespace aux_wip {
             enum { num_lua_args = 3 }; // DONT FORGET ME!!
 
             if (lua_pcall(l, num_lua_args, LUA_MULTRET, errorHandler) != LUA_OK) {
-                print_top_string(l, "Lua unable to execute init.lua and etc");
+                print_top_string(l, "unable to execute init.lua and etc");
                 return false;
             }
 
@@ -158,7 +159,7 @@ namespace lua { namespace aux_wip {
         static int LuaErrorHandler(lua_State *l) {
 
             int message = lua_gettop(l);//1
-            print_top_string(l, "Lua error");
+            print_top_string(l, "error");
 
             lua_getglobal(l, "debug");//2
             lua_pushstring(l, "traceback");
@@ -167,7 +168,7 @@ namespace lua { namespace aux_wip {
 
             lua_call(l, 0, 1);
 
-            print_top_string(l, "Lua trace");
+            print_top_string(l, "trace");
 
             lua_pushvalue(l, message);
             return 1;
@@ -231,9 +232,7 @@ namespace lua { namespace aux_wip {
         }
 
         void warn_if_aquired() {
-            if (_aquired_count > 0) { // ololo. N contexts are still aquired, crash possible!
-                assert(false);
-            }
+            jc_assert_msg(_aquired_count == 0, "Lua: %u lua-contexts are still active and used", _aquired_count);
         }
     };
 
@@ -256,13 +255,15 @@ namespace lua { namespace aux_wip {
     };
 
 
-    struct fixture : testing::Fixture {
+    struct fixture : public ::testing::Test {
         tes_context tc;
         context_pool pool;
         fixture() : pool(tc) {}
     };
 
-    TEST_F(fixture, Lua, trtr)
+#if 1
+
+    TEST_F(fixture, Lua_trtr)
     {
         std::atomic_int8_t stop = 0;
 
@@ -281,33 +282,18 @@ namespace lua { namespace aux_wip {
         t2.join();
     }
 
-    TEST_F(fixture, Lua, evalLua)
+    TEST_F(fixture, Lua_evalLua)
     {
-        /*
-        auto result = eval_lua_function_for_test(l, &array::object(tes_context::instance()),
-        "assert(jobject);"
-        "local obj = JArray.objectWithArray {1,2,3,4,9};"
-        "return jc.filter(obj, function(x) return x < 3.5 end);"
-        );
-
-        EXPECT_TRUE(result);
-
-        auto obj = result->object();
-        EXPECT_NOT_NIL(obj);
-        auto filtered = result->object()->as<array>();
-        EXPECT_NOT_NIL(filtered);
-        EXPECT_TRUE(filtered->s_count() == 3);*/
-
         autofreed_context lc(pool);
 
         auto testTransporting = [&](const char *str) { return lc->eval_lua_function(nullptr, str); };
 
         EXPECT_TRUE(*testTransporting("return 10") == 10.0f);
         EXPECT_TRUE(*testTransporting("return 'die'") == std::string("die"));
-        EXPECT_TRUE(*testTransporting("return Form(20)") == FormId(20));
+        EXPECT_TRUE(*testTransporting("return Form(20)") == cl::make_weak_form_id(FormId(20), tc));
 
 
-        auto& db = *tc.database();
+        auto& db = tc.root();
         EXPECT_TRUE(*testTransporting("return JDB") == db.base());
 
         db.set("test", 10);
@@ -323,22 +309,22 @@ namespace lua { namespace aux_wip {
 
     }
 
-    TEST_F(fixture, Lua, launch_all_lua_tests)
+    TEST_F(fixture, Lua_launch_all_lua_tests)
     {
         EXPECT_TRUE(autofreed_context(pool)->eval_lua_function(nullptr, "return testing.perform()")->intValue() != 0);
     }
-
+#endif
 }
 }
 
 namespace lua {
 
     boost::optional<item> eval_lua_function(tes_context& ctx, object_base *object, const char *lua_string) {
-        auto pool = static_cast<aux_wip::context_pool*>(*ctx.lua_context);
+        auto pool = static_cast<aux_wip::context_pool*>(ctx.lua_context.get());
         return aux_wip::autofreed_context(*pool)->eval_lua_function(object, lua_string);
     }
 
     static tes_context::post_init g_extender([](tes_context& ctx){
-        ctx.lua_context = std::make_unique<collections::dependent_context*>(new aux_wip::context_pool(ctx));
+        ctx.lua_context = std::make_shared<aux_wip::context_pool>(ctx);
     });
 }
diff --git a/JContainers/src/lua_module.h b/JContainers/src/collections/lua_module.h
similarity index 100%
rename from JContainers/src/lua_module.h
rename to JContainers/src/collections/lua_module.h
diff --git a/JContainers/src/lua_native_funcs.hpp b/JContainers/src/collections/lua_native_funcs.hpp
similarity index 82%
rename from JContainers/src/lua_native_funcs.hpp
rename to JContainers/src/collections/lua_native_funcs.hpp
index 1ba66f3..b4e28b8 100644
--- a/JContainers/src/lua_native_funcs.hpp
+++ b/JContainers/src/collections/lua_native_funcs.hpp
@@ -9,6 +9,11 @@ namespace lua {
     using formmap_functions = collections::formmap_functions;
     using array_functions = collections::array_functions;
     using CollectionType = collections::CollectionType;
+
+    using collections::form_ref;
+    using collections::FormId;
+    using collections::FormIdUnredlying;
+    using collections::HACK_get_tcontext;
 }
 
 namespace lua { namespace api {
@@ -89,8 +94,8 @@ namespace lua { namespace api {
                 value.object = { val.get() };
             }
 
-            void operator ()(const FormId& val) {
-                value.form = { val };
+            void operator ()(const form_ref& val) {
+                value.form = { (FormIdUnredlying)val.get() };
             }
 
         } converter;
@@ -104,10 +109,10 @@ namespace lua { namespace api {
         return itm ? JCToLuaValue_fromItem(*itm) : JCToLuaValue_None();
     }
 
-    void JCValue_fillItem(const JCValue *v, item& itm) {
+    void JCValue_fillItem(tes_context& context, const JCValue *v, item& itm) {
         switch (v ? v->type : item_type::no_item) {
         case item_type::form:
-            itm = (FormId)v->form.___id;
+            itm = collections::make_weak_form_id((FormId)v->form.___id, context);
             break;
         case item_type::integer:
             itm = v->integer;
@@ -197,7 +202,7 @@ namespace lua { namespace api {
 
     cexport void JArray_setValue(array* obj, index key, const JCValue* val) {
         array_functions::doReadOp(obj, key, [=](index idx) {
-            JCValue_fillItem(val, obj->u_container()[idx]);
+            JCValue_fillItem(HACK_get_tcontext(*obj), val, obj->u_container()[idx]);
         });
         //std::cout << "value assigned: " << JCValue_toString(val) << std::endl;
     }
@@ -205,7 +210,7 @@ namespace lua { namespace api {
     cexport void JArray_insert(array* obj, const JCValue* val, index key) {
         array_functions::doWriteOp(obj, key, [=](index idx) {
             auto& cnt = obj->u_container();
-            JCValue_fillItem(val, *cnt.insert(cnt.begin() + idx, item()));
+            JCValue_fillItem(HACK_get_tcontext(*obj), val, *cnt.insert(cnt.begin() + idx, item()));
         });
         //std::cout << "value assigned: " << JCValue_toString(val) << std::endl;
     }
@@ -218,7 +223,7 @@ namespace lua { namespace api {
     }
 
     cexport void JMap_setValue(map *obj, cstring key, const JCValue* val) {
-        map_functions::doWriteOp(obj, key, [val](item& itm) { JCValue_fillItem(val, itm); });
+        map_functions::doWriteOp(obj, key, [obj, val](item& itm) { JCValue_fillItem(HACK_get_tcontext(*obj), val, itm); });
     }
 
     cexport JCToLuaValue JMap_getValue(map *obj, cstring key) {
@@ -229,21 +234,29 @@ namespace lua { namespace api {
     static_assert(sizeof FormId == sizeof CForm, "");
 
     cexport FormId JFormMap_nextKey(const form_map *obj, FormId lastKey) {
-        FormId next = FormId::FormZero;
-        formmap_functions::nextKey(obj, lastKey, [&](const FormId& key) { next = key; });
-        return next;
+        form_ref next;
+        formmap_functions::nextKey(obj, make_weak_form_id(lastKey, HACK_get_tcontext(*obj)), [&](const form_ref& key) { next = key; });
+        return next.get();
     }
 
     cexport void JFormMap_setValue(form_map *obj, FormId key, const JCValue* val) {
-        formmap_functions::doWriteOp(obj, key, [val](item& itm) { JCValue_fillItem(val, itm); });
+        formmap_functions::doWriteOp(obj, make_weak_form_id(key, HACK_get_tcontext(*obj)), [obj, val](item& itm) { JCValue_fillItem(HACK_get_tcontext(*obj), val, itm); });
     }
 
     cexport JCToLuaValue JFormMap_getValue(form_map *obj, FormId key) {
-        return formmap_functions::doReadOpR(obj, key, JCToLuaValue_None(), [](item& itm) { return JCToLuaValue_fromItem(itm); });
+        return formmap_functions::doReadOpR(obj, make_weak_form_id(key, HACK_get_tcontext(*obj)), JCToLuaValue_None(), [](item& itm) { return JCToLuaValue_fromItem(itm); });
     }
 
+    cexport void JFormMap_removeKey(form_map *obj, FormId key) {
+        if (obj) {
+            obj->erase(make_weak_form_id(key, HACK_get_tcontext(*obj)));
+        }
+    }
+
+    ////////////////////////////
+
     cexport handle JDB_instance(tes_context *jc_context) {
-        return jc_context->database();
+        return &jc_context->root();
     }
 }
 }
\ No newline at end of file
diff --git a/JContainers/src/collection_operators.h b/JContainers/src/collections/operators.h
similarity index 98%
rename from JContainers/src/collection_operators.h
rename to JContainers/src/collections/operators.h
index 0abe5f8..b7013ea 100644
--- a/JContainers/src/collection_operators.h
+++ b/JContainers/src/collections/operators.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#include "collections.h"
+#include "collections/collections.h"
 
 #include <thread>
 #include "meta.h"
@@ -8,7 +8,7 @@
 
 namespace collections {
 
-    namespace collection_operators
+    namespace operators
     {
         using istring = util::istring;
         typedef void (*operator_func)(const item& val, item& state);
diff --git a/JContainers/src/collections.tests.base.h b/JContainers/src/collections/tests.h
similarity index 86%
rename from JContainers/src/collections.tests.base.h
rename to JContainers/src/collections/tests.h
index ed74614..00cfdc9 100644
--- a/JContainers/src/collections.tests.base.h
+++ b/JContainers/src/collections/tests.h
@@ -2,12 +2,16 @@
 
 namespace collections {
 
-    struct JCFixture : testing::Fixture {
+    struct JCFixture : public ::testing::Test {
         tes_context context;
+
+/*
+        void SetUpTestCase(){}
+        void TearDownTestCase(){}*/
     };
 
-#   define JC_TEST(name, name2) TEST_F(JCFixture, name, name2)
-#   define JC_TEST_DISABLED(name, name2) TEST_F(JCFixture, name, DISABLED_##name2)
+#   define JC_TEST(name, name2) TEST_F(JCFixture, name ## _ ## name2)
+#   define JC_TEST_DISABLED(name, name2) TEST_F(JCFixture, name ## _DISABLED_ ## name2)
 
 }
 
@@ -26,7 +30,7 @@ namespace collections { namespace {
         obj->tes_retain();
         EXPECT_TRUE(obj->refCount() == 1 + 3);
 
-        // ensure that over-release does not affects internal ref count:
+        // ensure that over-release does not affect internal ref count:
         for (int i = 0; i < 20; i++) {
             obj->tes_release();
         }
@@ -50,11 +54,8 @@ namespace collections { namespace {
         i1 = (const char*)nullptr;
         EXPECT_TRUE(i1.isNull());
 
-        i1 = (TESForm*)nullptr;
-        EXPECT_TRUE(i1.isNull());
-
-        i1 = FormZero;
-        EXPECT_TRUE(i1.isNull());
+        i1 = form_ref{};
+        EXPECT_FALSE(i1.isNull());
 
         i1 = (object_base *)nullptr;
         EXPECT_TRUE(i1.isNull());
@@ -94,11 +95,9 @@ namespace collections { namespace {
     {
         EXPECT_TRUE(item(100) < item(2.0));
         EXPECT_TRUE(item(1.0) < item(2.0));
-        EXPECT_TRUE(item(10) < item(FormZero));
+        EXPECT_TRUE(item(10) < item( form_ref() ));
         EXPECT_TRUE(item("aa") < item("text"));
         EXPECT_TRUE(item("A") < item("b"));
-
-        //EXPECT_TRUE(Item(1.0) < Item(FormZero));
     }
 
     TEST(form_handling, test)
@@ -228,9 +227,9 @@ namespace collections { namespace {
 
     // load json file into tes_context -> serialize into json again -> compare with original json
     // also compares original json with json, loaded from serialized tex_context (do_comparison2 function)
-    struct json_loading_test : testing::Fixture {
+    struct json_loading_test_ {
 
-        void test() {
+        static void test() {
 
             namespace fs = boost::filesystem;
 
@@ -249,7 +248,7 @@ namespace collections { namespace {
             EXPECT_TRUE(atLeastOneTested);
         }
 
-        void do_comparison(const char *file_path) {
+        static void do_comparison(const char *file_path) {
             EXPECT_NOT_NIL(file_path);
 
             auto jsonOut = make_unique_ptr((json_t*)nullptr, &json_decref);
@@ -263,17 +262,20 @@ namespace collections { namespace {
             auto originJson = json_deserializer::json_from_file(file_path);
             EXPECT_NOT_NIL(originJson);
 
+            auto originJson_text = json_dumps(originJson.get(), 0);
+            auto jsonOut_text = json_dumps(jsonOut.get(), 0);
+
             EXPECT_TRUE(json_equal(originJson.get(), jsonOut.get()) == 1);
         }
 
-        void do_comparison2(const char *file_path) {
+        static void do_comparison2(const char *file_path) {
             EXPECT_NOT_NIL(file_path);
 
             auto jsonOut = make_unique_ptr((json_t*)nullptr, &json_decref);
             {
                 tes_context ctx;
 
-                Handle rootId = HandleNull;
+                Handle rootId = Handle::Null;
                 {
                     auto root = json_deserializer::object_from_file(ctx, file_path);
                     EXPECT_NOT_NIL(root);
@@ -295,7 +297,9 @@ namespace collections { namespace {
         }
     };
 
-    TEST_F_CUSTOM_CLASS(json_loading_test, t);
+    TEST(json_loading_test, t) {
+        json_loading_test_::test();
+    }
 
     JC_TEST(json_serializer, no_infinite_recursion)
     {
@@ -316,6 +320,19 @@ namespace collections { namespace {
         }
     }
 
+    JC_TEST(json_handling, old_json_still_supported)
+    {
+        object_base* root = json_deserializer::object_from_json_data(context, STR(
+            {
+                "__formData": null,
+                "__formData|D|0x4" : []
+            }
+        ));
+
+        EXPECT_NOT_NIL(root);
+        EXPECT_NOT_NIL(root->as<form_map>());
+    }
+
     JC_TEST(json_handling, object_references)
     {
         object_base* root = json_deserializer::object_from_json_data(context, STR(
@@ -338,9 +355,9 @@ namespace collections { namespace {
         }
         ));
 
-        auto compareRefs = [&](object_base *root, const char *path1, const char *path2) {
-            auto o1 = path_resolving::_resolve<object_base*>(context, root, path1);
-            auto o2 = path_resolving::_resolve<object_base*>(context, root, path2);
+        auto compareRefs = [&](object_base &root, const char *path1, const char *path2) {
+            auto o1 = ca::get(root, path1)->object();
+            auto o2 = ca::get(root, path2)->object();
             EXPECT_TRUE(o1 && o2 && o1 == o2);
         };
 
@@ -351,12 +368,11 @@ namespace collections { namespace {
             const char *equalPaths[][2] = {
                 ".parentArray[0]", ".parentArray[1].referenceToChildJMap1",
                 ".parentArray[0]", ".parentArray[1].referenceToChildJMap1",
-                ".parentArray[0].rootRef", "",
                 ".parentArray[2][__formData|D|0x4]", ".parentArray[1].referenceToFormMapValue"
             };
 
             for (auto& pair : equalPaths) {
-                compareRefs(root, pair[0], pair[1]);
+                compareRefs(*root, pair[0], pair[1]);
             }
         };
 
@@ -364,31 +380,36 @@ namespace collections { namespace {
         validateGraph(root);
 
         auto jvalue = json_serializer::create_json_value(*root);
+        auto json_text = json_serializer::create_json_data(*root);
         auto root2 = json_deserializer::object_from_json(context, jvalue.get());
         validateGraph(root2);
     }
 
-    JC_TEST(tes_context, backward_compatibility)
+    TEST(tes_context, backward_compatibility)
     {
         namespace fs = boost::filesystem;
 
         fs::path dir = util::relative_to_dll_path("test_data/backward_compatibility");
-        fs::directory_iterator end;
         bool atLeastOneTested = false;
 
-        for (fs::directory_iterator itr(dir); itr != end; ++itr) {
+        for (fs::directory_iterator itr(dir), end; itr != end; ++itr) {
             if (fs::is_regular_file(*itr)) {
                 atLeastOneTested = true;
 
                 std::ifstream file(itr->path().generic_string(), std::ios::in | std::ios::binary);
+
+                tes_context context;
                 context.read_from_stream(file);
+                context._form_watcher.u_print_status();
+
+                EXPECT_TRUE(context.object_count() > 100); // dumb assumption
             }
         }
 
         EXPECT_TRUE(atLeastOneTested);
     }
 
-    JC_TEST(deep_copying, _)
+    JC_TEST(copying, _)
     {
         {
             // array containing himself
@@ -399,7 +420,7 @@ namespace collections { namespace {
             EXPECT_TRUE(root[0] == root.base());
             //EXPECT_NOT_NIL(root);
 
-            array& copy = deep_copying::deep_copy(context, root).as_link<array>();
+            array& copy = copying::deep_copy(context, root).as_link<array>();
             EXPECT_TRUE(&copy != &root);
 
             EXPECT_TRUE(copy[0] == copy.base());
@@ -412,7 +433,7 @@ namespace collections { namespace {
                 { "c": "__reference|.b", "b": [] }
             ))->as_link<map>();
 
-            auto& copy = deep_copying::deep_copy(context, root).as_link<map>();
+            auto& copy = copying::deep_copy(context, root).as_link<map>();
             EXPECT_TRUE(&copy != &root);
             EXPECT_TRUE(root.s_count() == 2);
             EXPECT_TRUE(copy.s_count() == 2);
@@ -428,7 +449,7 @@ namespace collections { namespace {
 				{ "c": 8.0, "obj" : [] }
 			))->as_link<map>();
 
-			auto& copy = deep_copying::shallow_copy(context, orig).as_link<map>();
+			auto& copy = copying::shallow_copy(context, orig).as_link<map>();
             EXPECT_TRUE(&copy != &orig);
             EXPECT_TRUE(orig.s_count() == 2);
 			EXPECT_TRUE(copy.s_count() == 2);
@@ -440,14 +461,12 @@ namespace collections { namespace {
 
     JC_TEST(garbage_collection, no_deadlopp_proof)
     {
-        auto obj = json_deserializer::object_from_json_data(context, STR([[[ "__reference|" ]]]));
-        EXPECT_NOT_NIL(obj);
-        obj->tes_retain();
+        auto& obj = array::objectWithInitializer([](array& me) { me.u_push(me); }, context);
+        obj.tes_retain();
 
         EXPECT_TRUE(context.collect_garbage() == 0);
 
-        obj = json_deserializer::object_from_json_data(context, STR([["__reference|"]]));
-        EXPECT_NOT_NIL(obj);
+        auto& obj2 = array::objectWithInitializer([](array& me) { me.u_push(me); }, context);
         context.collect_garbage();
     }
 
@@ -466,7 +485,7 @@ namespace collections { namespace {
             for (int j = 0; j < 10; ++j) {
                 auto rnd = rand() % 10;
 
-                cont->push(item(arrays[rnd]));
+                cont->push(arrays[rnd]);
             }
         }
 
@@ -487,26 +506,25 @@ namespace collections { namespace {
         std::string name = "back in black";
         cnt.u_set("ACDC", name);
 
-        EXPECT_TRUE(*cnt.u_get("acdc")->stringValue() == name);
+        EXPECT_TRUE(*cnt.u_get("acdc") == name);
     }
 
-    JC_TEST(tes_context, database)
+    JC_TEST(tes_context, root)
     {
-        auto db = context.database();
-        EXPECT_TRUE(db != nullptr);
-        EXPECT_TRUE(db == context.database());
+        auto& db = context.root();
+        EXPECT_TRUE(&db == &context.root());
     }
 
-    JC_TEST(tes_context, database_setter)
+    JC_TEST(tes_context, root_gets_retained)
     {
         auto root = &map::object(context);
         auto rc1 = root->refCount();
-        context.setDataBase(root);
+        context.set_root(root);
         const auto rcDiff = root->refCount() - rc1;
         EXPECT_TRUE(rcDiff > 0);
 
         auto rc2 = root->refCount();
-        context.setDataBase(nullptr);
+        context.set_root(nullptr);
         const auto rcDiff2 = - root->refCount() + rc2;
         // had to hardcode this - old. db gets released, gets retained by aqueue, thus -rcDiff2 != rcDiff
         EXPECT_TRUE((1 + rcDiff2) == rcDiff);
diff --git a/JContainers/src/collection_types.h b/JContainers/src/form_id.h
similarity index 37%
rename from JContainers/src/collection_types.h
rename to JContainers/src/form_id.h
index 690b5d9..0616740 100644
--- a/JContainers/src/collection_types.h
+++ b/JContainers/src/form_id.h
@@ -4,8 +4,16 @@
 
 namespace collections {
 
-    enum FormId : uint32_t {
-        FormZero = 0,
+    using FormIdUnredlying = uint32_t;
+
+    enum class FormId : FormIdUnredlying {
+        Zero = 0,
+    };
+
+    enum class FormHandle : uint64_t {
+    };
+
+    enum {
         FormGlobalPrefix = 0xFF,
     };
 }
diff --git a/JContainers/src/gtest.h b/JContainers/src/gtest.h
index d72cf91..2e4036c 100644
--- a/JContainers/src/gtest.h
+++ b/JContainers/src/gtest.h
@@ -1,8 +1,14 @@
 #pragma once
 
-//#include "typedefs.h"
-#include "meta.h"
+#include "../dep/googletest/googletest/googletest/include/gtest/gtest.h"
+//#include "meta.h"
 
+
+#define EXPECT_NOT_NIL(expr) EXPECT_NE((expr), nullptr)
+#define EXPECT_NIL(expr) EXPECT_EQ((expr), nullptr)
+
+
+/*
 namespace testing
 {
     struct State;
@@ -74,21 +80,23 @@ namespace testing
 
 #   define TEST_DISABLED(name, name2) TEST(name, DISABLED_##name2)
 
-#   define EXPECT_TRUE(expression) ::testing::check(testState, expression, __FUNCTION__, #expression " is false");
-#   define EXPECT_FALSE(expression)  ::testing::check(testState, !(expression), __FUNCTION__, #expression " is true");
-#   define EXPECT_EQ(a, b) ::testing::check(testState, (a) == (b), __FUNCTION__, #a " != " #b);
+#   define _LOCATION  __FUNCTION__ " line " STR(__LINE__)
+
+#   define EXPECT_TRUE(expression) ::testing::check(testState, expression, _LOCATION, #expression " is false");
+#   define EXPECT_FALSE(expression)  ::testing::check(testState, !(expression), _LOCATION, #expression " is true");
+#   define EXPECT_EQ(a, b) ::testing::check(testState, (a) == (b), _LOCATION, #a " != " #b);
 
-#   define EXPECT_NOT_NIL(expression) ::testing::check(testState, (expression) != nullptr, __FUNCTION__, #expression " is null ");
-#   define EXPECT_NIL(expression) ::testing::check(testState, (expression) == nullptr, __FUNCTION__, #expression " is not null ");
+#   define EXPECT_NOT_NIL(expression) ::testing::check(testState, (expression) != nullptr, _LOCATION, #expression " is null ");
+#   define EXPECT_NIL(expression) ::testing::check(testState, (expression) == nullptr, _LOCATION, #expression " is not null ");
 
 #   define EXPECT_THROW(expression, exception) \
         try { \
             expression; \
-            ::testing::check(testState, false, __FUNCTION__, "'" #expression "' does not throws nor '" #exception "' nor any other exception"); \
+            ::testing::check(testState, false, _LOCATION, "'" #expression "' does not throws nor '" #exception "' nor any other exception"); \
         } \
         catch( const exception& ) {;} \
         catch(...) { \
-            ::testing::check(testState, false, __FUNCTION__,  "'" #expression "' does not throws '" #exception "' exception, but throws unknown exception"); \
+            ::testing::check(testState, false, _LOCATION,  "'" #expression "' does not throws '" #exception "' exception, but throws unknown exception"); \
             throw; \
         }
 
@@ -96,6 +104,7 @@ namespace testing
         try { \
             expression; \
         } catch(...) { \
-            ::testing::check(testState, false, __FUNCTION__, "'" #expression "' throws exception"); \
+            ::testing::check(testState, false, _LOCATION, "'" #expression "' throws exception"); \
         }
 }
+*/
diff --git a/JContainers/src/iarchive_with_blob.h b/JContainers/src/iarchive_with_blob.h
new file mode 100644
index 0000000..ce1db22
--- /dev/null
+++ b/JContainers/src/iarchive_with_blob.h
@@ -0,0 +1,61 @@
+#pragma once
+#include <boost/archive/binary_iarchive.hpp>
+#include <type_traits>
+#include <tuple>
+#include <assert.h>
+
+namespace collections {
+    class tes_context;
+    class object_context;
+}
+
+namespace hack {
+
+    using iarchive_with_blob_base = boost::archive::binary_iarchive;
+
+    //boost::archive::binary_iarchive
+    // To carry all necessay information needed to initialize objects from older archive formats
+    // Should be replaced with boost::archive::binary_iarchive when this class won't be needed
+    template<class T0, class T1>
+    class iarchive_with_blob_templ : public iarchive_with_blob_base {
+        std::tuple<T0&,T1&> _blob;
+    public:
+
+        template<class T> T& get() {
+            return std::get<T&>(_blob);
+        }
+
+        template<> T0& get<T0>() {
+            return std::get<0>(_blob);
+        }
+
+        template<> T1& get<T1>() {
+            return std::get<1>(_blob);
+        }
+
+        iarchive_with_blob_templ() = delete;
+
+        template<class ...Types>
+        explicit iarchive_with_blob_templ(std::istream & stream, Types& ...args)
+            : iarchive_with_blob_base(stream)
+            , _blob(args ...)
+        {}
+
+        template<class T>
+        static T& from_base_get(iarchive_with_blob_base& base) {
+            auto blob = dynamic_cast<iarchive_with_blob_templ*>(&base);
+            assert(blob);
+            return blob->get<T>();
+        }
+    };
+
+    using iarchive_with_blob = iarchive_with_blob_templ < collections::tes_context, collections::object_context > ;
+
+    static_assert(std::has_virtual_destructor<boost::archive::binary_iarchive>::value, "it MUST implement virtual destructor");
+    static_assert(std::is_base_of<boost::archive::binary_iarchive, iarchive_with_blob>::value, "");
+
+}
+/*
+
+BOOST_SERIALIZATION_REGISTER_ARCHIVE(hack::iarchive_with_blob);
+BOOST_SERIALIZATION_USE_ARRAY_OPTIMIZATION(hack::iarchive_with_blob);*/
diff --git a/JContainers/src/jc_interface.cpp b/JContainers/src/jc_interface.cpp
index 454a1d7..f7dde8a 100644
--- a/JContainers/src/jc_interface.cpp
+++ b/JContainers/src/jc_interface.cpp
@@ -1,5 +1,5 @@
 #include "jc_interface.h"
-#include "reflection.h"
+#include "reflection/reflection.h"
 
 namespace jc { namespace {
 
diff --git a/JContainers/src/jcontainers_constants.h b/JContainers/src/jcontainers_constants.h
index 31f4d35..9a20cb4 100644
--- a/JContainers/src/jcontainers_constants.h
+++ b/JContainers/src/jcontainers_constants.h
@@ -7,8 +7,8 @@ namespace collections {
 
 #   define JC_PLUGIN_NAME           "JContainers"
 #   define JC_API_VERSION           3
-#   define JC_FEATURE_VERSION       2
-#   define JC_PATCH_VERSION         5
+#   define JC_FEATURE_VERSION       3
+#   define JC_PATCH_VERSION         0
 
 #   define VER_FILE_VERSION         JC_API_VERSION, JC_FEATURE_VERSION, JC_PATCH_VERSION, 0
 
diff --git a/JContainers/src/meta.h b/JContainers/src/meta.h
index 9c662c5..41cd969 100644
--- a/JContainers/src/meta.h
+++ b/JContainers/src/meta.h
@@ -1,8 +1,5 @@
 #pragma once
 
-// ,  -     .
-//  , ,    
-// ,        
 // Class that contains meta-info
 // Meta-info gets gathered during dynamic initialization and gets pushed into list
 // It's assumed that meta class instance will reside in static memory only!
diff --git a/JContainers/src/object/autorelease_queue.h b/JContainers/src/object/autorelease_queue.h
index 38d5a8d..469db31 100644
--- a/JContainers/src/object/autorelease_queue.h
+++ b/JContainers/src/object/autorelease_queue.h
@@ -5,9 +5,13 @@
 #include <boost\serialization\version.hpp>
 #include <boost\asio\io_service.hpp>
 #include <boost\asio\deadline_timer.hpp>
+#include "common\IThread.h"
+#include "util\util.h"
 
 namespace collections {
 
+#define WINE_SUPPORT 1
+
     class object_registry;
 
     // The purpose of autorelease_queue (aqueue) is to temporarily own an object and increase an object's lifetime
@@ -34,16 +38,19 @@ namespace collections {
         object_registry& _registry;
         queue _queue;
         time_point _tickCounter;
-
         spinlock _queue_mutex;
-        spinlock _timer_mutex;
         
         // it's not overkill to use asio?
         boost::asio::io_service _io;
         boost::asio::io_service::work _work;
         boost::asio::deadline_timer _timer;
+        std::mutex _timer_mutex;
+        bool _timer_stopped = true;
+#   if WINE_SUPPORT
+        IThread _thread;
+#   else
         std::thread _thread;
-
+#   endif
         // reusable array for temp objects
         std::vector<queue_object_ref> _toRelease;
 
@@ -115,9 +122,14 @@ namespace collections {
             , _work(_io)
             , _timer(_io)
         {
+#   if WINE_SUPPORT
+            using io_ptr_type = decltype(_io);
+            _thread.Start([](void *io_ptr) { reinterpret_cast<io_ptr_type*>(io_ptr)->run(); }, &_io);
+#   else
             _thread = std::thread([&]() { _io.run(); });
+#   endif
             start();
-            jc_debug("aqueue created")
+            //jc_debug("aqueue created")
         }
 
         // prolongs object lifetime for ~10 seconds
@@ -133,7 +145,7 @@ namespace collections {
 
         void not_prolong_lifetime(object_base& object) {
             if (object.is_in_aqueue()) {
-                jc_debug("aqueue: removed id - %u", object._uid());
+                //jc_debug("aqueue: removed id - %u", object._uid());
                 spinlock::guard g(_queue_mutex);
                 object._aqueue_push_time = time_subtract(_tickCounter, obj_lifeInTicks);
             }
@@ -155,14 +167,21 @@ namespace collections {
 
         // starts asynchronouos aqueue run, asynchronouosly releases objects when their time comes, starts timers, 
         void start() {
-            restartTimer();
+            std::lock_guard<std::mutex> g(_timer_mutex);
+            if (_timer_stopped) {
+                _timer_stopped = false;
+                u_startTimer();
+            }
         }
 
-        // stops async. processes launched by @start function
+        // stops async. processes launched by @start function,
         void stop() {
-            // will wait for @tick function execution completion
-            spinlock::guard g(_timer_mutex);
-            _timer.cancel();
+            // with _timer_mutex locked it will wait for @tick function execution completion
+            // the point is to execute @stop after @tick (so @tick will not auto-restart the timer)
+            std::lock_guard<std::mutex> g(_timer_mutex);
+            _timer_stopped = true;
+            auto callbacks_cancelled = _timer.cancel();
+            jc_assert(callbacks_cancelled <= 1);
         }
 
         void u_nullify() {
@@ -177,10 +196,16 @@ namespace collections {
 
             stop();
             _io.stop();
+
+#   if WINE_SUPPORT
+            _thread.Stop();
+            WaitForSingleObject(_thread.GetHandle(), INFINITE);
+#   else
             if (_thread.joinable()) {
                 _thread.join();
             }
-            jc_debug("aqueue destroyed")
+#   endif
+            //jc_debug("aqueue destroyed")
         }
 
     public:
@@ -223,30 +248,25 @@ namespace collections {
 
     private:
 
-        void restartTimer() {
-            spinlock::guard g(_timer_mutex);
-            u_startTimer();
-        }
-
         void u_startTimer() {
+
             boost::system::error_code code;
             _timer.expires_from_now(boost::posix_time::seconds(tick_duration), code);
             assert(!code);
 
-            _timer.async_wait([&](const boost::system::error_code& e) {
-                //jc_debug("aqueue code: %s - %u", e.message().c_str(), e.value());
-                if (!e) { // i.e. means no error, successful completion
-                    tick();
+            _timer.async_wait([this](const boost::system::error_code& error) {
+                std::lock_guard<std::mutex> g(_timer_mutex);
+                if (!error && !_timer_stopped) { // !e means no error, no cancel, successful completion
+                    this->tick();
+                    this->u_startTimer();
 				}
 				else {
-					jc_debug("aqueue timer was cancelled");
+					//jc_debug("aqueue timer was cancelled");
 				}
             });
         }
 
         void tick() {
-            spinlock::guard g(_timer_mutex);
-            
             {
                 spinlock::guard g(_queue_mutex);
                 _queue.erase(
@@ -275,8 +295,6 @@ namespace collections {
             // tes ..
             // Item..
             _toRelease.clear();
-
-            u_startTimer();
         }
     };
 
diff --git a/JContainers/src/object/id_generator.h b/JContainers/src/object/id_generator.h
index a3b0a73..4dc57f7 100644
--- a/JContainers/src/object/id_generator.h
+++ b/JContainers/src/object/id_generator.h
@@ -2,42 +2,6 @@
 
 namespace collections {
 
-
-    template<class ID>
-    struct id_generator_0 {
-        std::vector<ID> m_freeNums;
-        ID m_highest; // i.e. [m_highest + 1, max(ID)] is free range
-
-        id_generator_0() : m_highest(0) {}
-        /*
-        ID newId() {
-            if (!m_freeNums.empty()) {
-                int num = m_freeNums.back();
-                m_freeNums.pop_back();
-                return num;
-            }
-
-            ++m_highest;
-            return m_highest;
-        }
-
-        void reuseId(ID num) {
-            m_freeNums.push_back(num);
-        }
-
-        void u_clear() {
-            m_highest = 0;
-            m_freeNums.clear();
-        }
-        */
-        template<class Archive>
-        void load(Archive & ar) {
-            ar & m_freeNums;
-            ar & m_highest;
-        }
-    };
-
-
     template<
         class id,
         id min_identifier,
@@ -204,34 +168,7 @@ namespace collections {
                 _current_range = _empty_ranges.begin() + currIdx;
             }
                 break;
-            case 0:
-                load_0(ar);
-                break;
-            }
-        }
-
-        template <class Archive> void load_0(Archive& ar) {
-            _empty_ranges.clear();
-            _current_range = _empty_ranges.end();
-
-            id_generator_0<id> old;
-            old.load(ar);
-
-            std::sort(old.m_freeNums.begin(), old.m_freeNums.end());
-            old.m_freeNums.erase(std::unique(old.m_freeNums.begin(), old.m_freeNums.end()), old.m_freeNums.end());
-
-            for (const auto& num : old.m_freeNums) {
-
-                if (!_empty_ranges.empty() && num - _empty_ranges.back().last == 1) {
-                    _empty_ranges.back().last = num;
-                }
-                else {
-                    _empty_ranges.push_back(range::with_first_last(num, num));
-                }
             }
-
-            _empty_ranges.push_back(range::with_first_last(old.m_highest + 1, max_identifier));
-            _current_range = _empty_ranges.end() - 1;
         }
     };
 
diff --git a/JContainers/src/object/object_base.h b/JContainers/src/object/object_base.h
index 7afbe36..e8bf2ff 100644
--- a/JContainers/src/object/object_base.h
+++ b/JContainers/src/object/object_base.h
@@ -14,8 +14,8 @@ namespace collections {
 
     typedef UInt32 HandleT;
 
-    enum Handle : HandleT {
-        HandleNull = 0,
+    enum class Handle : HandleT {
+        Null = 0,
     };
 
     class object_base;
@@ -49,7 +49,7 @@ namespace collections {
         typedef uint32_t time_point;
 
     public:
-        Handle _id                              = HandleNull;
+        std::atomic<Handle> _id                 = Handle::Null;
 
         std::atomic_int32_t _refCount           = 0;
         std::atomic_int32_t _tes_refCount       = 0;
@@ -57,12 +57,14 @@ namespace collections {
         std::atomic_int32_t _aqueue_refCount    = 0;
         time_point _aqueue_push_time            = 0;
 
-        CollectionType                          _type;
+        CollectionType                          _type = CollectionType::None;
         boost::optional<util::istring>          _tag;
     private:
         object_context *_context                = nullptr;
 
         void release_counter(std::atomic_int32_t& counter);
+        bool is_completely_initialized() const { return _context != nullptr; }
+        void try_prolong_lifetime();
 
     public:
 
@@ -83,11 +85,11 @@ namespace collections {
         Handle public_id();
 
         CollectionType type() const { return _type; }
-        Handle _uid() const {  return _id; }
+        Handle _uid() const {  return _id.load(std::memory_order_relaxed); }
 		Handle uid();
 
         bool is_public() const {
-            return _id != HandleNull;
+            return _uid() != Handle::Null;
         }
 
         template<class T> T* as() {
@@ -98,6 +100,10 @@ namespace collections {
             return (this && T::TypeId == _type) ? static_cast<const T*>(this) : nullptr;
         }
 
+        template<> const object_base* as<object_base>() const {
+            return this;
+        }
+
         template<class T> T& as_link() {
             return const_cast<T&>(const_cast<const object_base*>(this)->as_link<T>());
         }
@@ -133,8 +139,7 @@ namespace collections {
             return _aqueue_refCount.load(std::memory_order_relaxed) > 0;
         }
 
-        // push object into the queue (which owns it)
-        // after some amount of time object will be released
+        // push the object into the queue (which will own it temporarily)
         object_base * prolong_lifetime();
         object_base * zero_lifetime();
 
@@ -169,7 +174,7 @@ namespace collections {
         // release calls and resulting deadlock
         virtual void u_nullifyObjects() = 0;
 
-        SInt32 s_count() {
+        SInt32 s_count() const {
             lock g(_mutex);
             return u_count();
         }
diff --git a/JContainers/src/object/object_base.hpp b/JContainers/src/object/object_base.hpp
index 4b61954..f269937 100644
--- a/JContainers/src/object/object_base.hpp
+++ b/JContainers/src/object/object_base.hpp
@@ -5,14 +5,19 @@ namespace collections
     }
 
     Handle object_base::public_id() {
-        if (_id == HandleNull) {
+        using namespace std;
+
+        auto id = _id.load(memory_order_acquire);
+        if (id == Handle::Null) {
             object_lock l(this);
-            if (_id == HandleNull) {
-                context().registry->registerNewObjectId(*this);
+            id = _id.load(memory_order_relaxed);
+            if (id == Handle::Null) {
+                id = context().registry->registerNewObjectId(*this);
+                _id.store(id, memory_order_release);
             }
         }
 
-        return _id;
+        return id;
     }
 
     /*
@@ -35,10 +40,16 @@ namespace collections
     */
 
     Handle object_base::uid() {
-        if (_id == HandleNull) {
+        using namespace std;
+
+        auto id = _id.load(memory_order_acquire);
+        if (id == Handle::Null) {
             object_lock l(this);
-            if (_id == HandleNull) {
-                context().registry->registerNewObjectId(*this);
+            id = _id.load(memory_order_relaxed);
+            if (id == Handle::Null) {
+                id = context().registry->registerNewObjectId(*this);
+                _id.store(id, memory_order_release);
+                
                 if (!_refCount) {
                     // prolong_lifetime if the object is not referenced by another objects -> should be done,
                     // as we must ensure that not-owned object will not hang forever
@@ -48,7 +59,7 @@ namespace collections
         }
 
         // it's possible that release from queue will happen just before public id will be exposed?
-        return _id;
+        return id;
     }
 
 	// AQueue is the only caller of the function. The function invoked when the object's lifetime expires.
@@ -84,7 +95,7 @@ namespace collections
             --_tes_refCount;
             if (noOwners()) {
                 // a user releases the object, no owners - I may even delete it immediately
-                context().aqueue->prolong_lifetime(*this, false);
+                context().aqueue->prolong_lifetime(*this, true);
             }
         }
     }
@@ -94,7 +105,7 @@ namespace collections
             --_stack_refCount;
             if (noOwners()) {
                 // the object no more referenced by Lua or stack, no owners - I may even delete it immediately
-                // (immediately if not exposed to Skyrim)
+                // (immediately if the object is not exposed to Skyrim, i.e. has no public ID)
                 prolong_lifetime();
             }
         }
@@ -108,12 +119,25 @@ namespace collections
             --_refCount;
             if (noOwners()) {
                 // the object get's erased from another object, no owners - I may even delete it immediately
-                // (immediately if not exposed to Skyrim)
-                prolong_lifetime();
+                // (immediately if the object is not exposed to Skyrim, i.e. has no public ID)
+
+                // Note that this function sometimes being called during loading (deserialization)
+                // We can't delete object during loading even if noOwners() is true - more owners may be loaded later
+                try_prolong_lifetime();
             }
         }
     }
 
+    // Issue: this method may be called during deserialization (e.g. object_base::release -> prolong_lifetime)
+    // Ofc. this causes crash because _context field is null, as the WHOLE system isn't completely initialized yet
+    // It's not clear how to solve this
+    // It's relatively safe to skip call - the object will be deleted by GC
+    void object_base::try_prolong_lifetime() {
+        if (this->is_completely_initialized()) { 
+            this->prolong_lifetime();
+        }
+    }
+
     object_base* object_base::prolong_lifetime() {
         context().aqueue->prolong_lifetime(*this, is_public());
         return this;
diff --git a/JContainers/src/object/object_base_serialization.h b/JContainers/src/object/object_base_serialization.h
index f5da2d1..944084b 100644
--- a/JContainers/src/object/object_base_serialization.h
+++ b/JContainers/src/object/object_base_serialization.h
@@ -4,25 +4,13 @@
 #include "boost\serialization\version.hpp"
 #include "boost\serialization\optional.hpp"
 
+#include "util/atomic_serialization.h"
 #include "object_base.h"
 
 namespace boost { namespace serialization {
 
     namespace cl = collections;
 
-    template<class Archive, class T>
-    void save_atomic(Archive& ar, const std::atomic<T>& v) {
-        T refCnt = v.load(std::memory_order_relaxed);
-        ar & refCnt;
-    }
-
-    template<class Archive, class T>
-    void load_atomic (Archive& ar, std::atomic<T> & v) {
-        T refCnt = (T)0;
-        ar & refCnt;
-        v.store(refCnt, std::memory_order_relaxed);
-    }
-
     template<class Archive>
     void save(Archive & ar, const cl::object_base & t, unsigned int version) {
         //jc_assert(version == 1);
@@ -45,7 +33,7 @@ namespace boost { namespace serialization {
         }
 
         save_atomic(ar, t._tes_refCount);
-        ar << t._id;
+        save_atomic(ar, t._id);
         ar << t._tag;
     }
 
@@ -68,12 +56,12 @@ namespace boost { namespace serialization {
         switch (version) {
         case 2:
         case 1:
-            ar >> t._id;
+            load_atomic(ar, t._id);
             ar >> t._tag;
             break;
         case 0:
             ar >> t._type;
-            ar >> t._id;
+            load_atomic(ar, t._id);
             break;
         default:
             jc_assert(false);
diff --git a/JContainers/src/object/object_context.h b/JContainers/src/object/object_context.h
index cfae2ed..e4d104d 100644
--- a/JContainers/src/object/object_context.h
+++ b/JContainers/src/object/object_context.h
@@ -3,6 +3,7 @@
 #include <atomic>
 #include <functional>
 #include <deque>
+#include <boost/serialization/split_member.hpp>
 
 #include "object_base.h"
 
@@ -29,8 +30,9 @@ namespace collections {
     enum class serialization_version {
         pre_aqueue_fix = 2,
         no_header = 3, // no JSON header in the beginning of a stream
-        pre_gc = 4, // next version adds GC 
-        current = 5,
+        pre_gc = 4, // next version implements GC
+        pre_dyn_form_watcher = 5, // next version implements dynamic-form-watcher
+        current = 6,
     };
 
     /*
@@ -45,19 +47,19 @@ namespace collections {
 
     class object_context {
 
-        void u_applyUpdates(const serialization_version saveVersion);
+    protected:
+        void u_postLoadInitializations();
         void u_postLoadMaintenance(const serialization_version saveVersion);
-
         void u_print_stats() const;
 
     public:
-        object_registry* registry;
-        autorelease_queue* aqueue;
+        std::unique_ptr<object_registry> registry;
+        std::unique_ptr<autorelease_queue> aqueue;
 
     public:
 
         object_context();
-        ~object_context();
+        virtual ~object_context();
 
         std::vector<object_stack_ref> filter_objects(std::function<bool(object_base& obj)> predicate) const;
 
@@ -71,34 +73,37 @@ namespace collections {
             return getObjectRef(hdl)->as<T>();
         }
 
-        size_t aqueueSize();
+        size_t aqueueSize() const;
+        size_t object_count() const;
         object_base * getObject(Handle hdl);
         object_stack_ref getObjectRef(Handle hdl);
         object_base * u_getObject(Handle hdl);
 
-        void clearState();
-        void u_clearState();
-        // complete shutdown, this context shouldn't be used for now
-        void shutdown();
-
-        void read_from_string(const std::string & data);
-        void read_from_stream(std::istream & data);
-
-        std::string write_to_string();
-        void write_to_stream(std::ostream& stream);
-
         // exposed for testing purposes only
         size_t collect_garbage();
+    public:
 
-    protected:
-        std::atomic<Handle> _root_object_id;
-        spinlock _lazyDBLock;
+        // stops object_context's activity, until destroyed and then restarts it 
+        struct activity_stopper {
+            object_context& context;
+            activity_stopper(object_context& context);
+            ~activity_stopper();
+        };
+
+        void stop_activity();
+        void u_clearState();
 
     public:
-        Handle root_id() const { return _root_object_id;}
 
-        object_base* root();
-        void set_root(object_base *db);
+        template<class Archive>
+        void load(Archive & ar, unsigned int version);
+        template<class Archive>
+        void save(Archive & ar, unsigned int version) const;
+
+        template<class Archive> void load_data_in_old_way(Archive& ar);
+
+        friend class boost::serialization::access;
+        BOOST_SERIALIZATION_SPLIT_MEMBER();
 
     private:
         spinlock _dependent_contexts_mutex;
diff --git a/JContainers/src/object/object_context.hpp b/JContainers/src/object/object_context.hpp
index f54af0c..5c2caab 100644
--- a/JContainers/src/object/object_context.hpp
+++ b/JContainers/src/object/object_context.hpp
@@ -1,27 +1,28 @@
 #include "util/util.h"
-#include <fstream>
 
 namespace collections
 {
-    template<class T, class D>
-    inline std::unique_ptr<T, D> make_unique_ptr(T* data, D destr) {
-        return std::unique_ptr<T, D>(data, destr);
-    }
-
     object_context::object_context()
-        : registry(nullptr)
-        , aqueue(nullptr)
-        , _root_object_id(HandleNull)
     {
-        registry = new object_registry();
-        aqueue = new autorelease_queue(*registry);
+        registry.reset(new object_registry{});
+        aqueue.reset(new autorelease_queue{ *registry });
     }
 
     object_context::~object_context() {
-        shutdown();
+    }
+
+    object_context::activity_stopper::activity_stopper(object_context& c)
+        : context(c)
+    {
+        c.stop_activity();
+    }
 
-        delete registry;
-        delete aqueue;
+    object_context::activity_stopper::~activity_stopper() {
+        context.aqueue->start();
+    }
+
+    void object_context::stop_activity() {
+        aqueue->stop();
     }
     
     void object_context::u_clearState() {
@@ -32,8 +33,6 @@ namespace collections
             }
         }
 
-        _root_object_id = HandleNull;
-
         /*  Not good, but working solution.
 
         purpose: free allocated memory
@@ -59,17 +58,6 @@ namespace collections
         }
     }
 
-    void object_context::shutdown() {
-        aqueue->stop();
-        u_clearState();
-    }
-
-    void object_context::clearState() {
-        aqueue->stop();
-        u_clearState();
-        aqueue->start();
-    }
-
     std::vector<object_stack_ref> object_context::filter_objects(std::function<bool(object_base& obj)> predicate) const {
         return registry->filter_objects(predicate);
     }
@@ -86,203 +74,51 @@ namespace collections
         return registry->u_getObject(hdl);
     }
 
-    size_t object_context::aqueueSize() {
+    size_t object_context::aqueueSize() const {
         return aqueue->count();
     }
 
+    size_t object_context::object_count() const {
+        return registry->object_count();
+    }
+
     size_t object_context::collect_garbage() {
-        aqueue->stop();
+        activity_stopper s{ *this };
         auto res = garbage_collector::u_collect(*registry, *aqueue);
-        aqueue->start();
         return res.garbage_total;
     }
 
     //////////////////////////////////////////////////////////////////////////
 
-    void object_context::read_from_string(const std::string & data) {
-        namespace io = boost::iostreams;
-        io::stream<io::array_source> stream( io::array_source(data.c_str(), data.size()) );
-        read_from_stream(stream);
-    }
-
-    struct header {
-
-        serialization_version updateVersion;
-
-        static header imitate_old_header() {
-            return{ serialization_version::no_header };
-        }
-
-        static header make() {
-            return{ serialization_version::current };
-        }
-
-        static const char *common_version_key() { return "commonVersion"; }
-
-        static header read_from_stream(std::istream & stream) {
-
-            uint32_t hdrSize = 0;
-            stream >> hdrSize;
-
-            std::vector<char> buffer(hdrSize);
-            stream.read(&buffer.front(), buffer.size());
-
-            auto js = make_unique_ptr(json_loadb(&buffer.front(), buffer.size(), 0, nullptr), &json_decref);
-            if (!js) { // parsing failed
-                return imitate_old_header();
-            }
-
-            return{ (serialization_version)json_integer_value(json_object_get(js.get(), common_version_key())) };
-        }
-
-        static auto write_to_json() -> decltype(make_unique_ptr((json_t *)nullptr, &json_decref)) {
-            auto header = make_unique_ptr(json_object(), &json_decref);
-
-            json_object_set(header.get(), common_version_key(), json_integer((json_int_t)serialization_version::current));
-
-            return header;
-        }
-
-        static void write_to_stream(std::ostream & stream) {
-            auto header = write_to_json();
-            auto data = make_unique_ptr(json_dumps(header.get(), 0), free);
-
-            uint32_t hdrSize = strlen(data.get());
-            stream << (uint32_t)hdrSize;
-            stream.write(data.get(), hdrSize);
-        }
-    };
-
-    void object_context::read_from_stream(std::istream & stream) {
-
-        stream.flags(stream.flags() | std::ios::binary);
-
-#       if 0
-        std::ofstream file("dump", std::ios::binary | std::ios::out);
-        std::copy(
-            std::istreambuf_iterator<char>(stream),
-            std::istreambuf_iterator<char>(),
-            std::ostreambuf_iterator<char>(file)
-            );
-        file.close();
-#       endif
-
-        aqueue->stop();
-        {
-            // i have assumed that Skyrim devs are not idiots to run scripts in process of save game loading
-            //write_lock g(_mutex);
-
-            u_clearState();
-
-            if (stream.peek() != std::istream::traits_type::eof()) {
-
-                try {
-
-                    auto hdr = header::read_from_stream(stream);
-                    bool isNotSupported = serialization_version::current < hdr.updateVersion || hdr.updateVersion <= serialization_version::no_header;
-
-                    if (isNotSupported) {
-                        std::ostringstream error;
-                        error << "Unable to load serialized data of version " << (int)hdr.updateVersion
-                            << ". Current serialization version is " << (int)serialization_version::current;
-                        throw std::logic_error(error.str());
-                    }
-
-                    {
-                        boost::archive::binary_iarchive archive(stream);
-                        archive >> *registry;
-                        archive >> *aqueue;
-                        boost::serialization::load_atomic(archive, _root_object_id);
-                    }
-
-                    {
-                        for (auto& obj : registry->u_all_objects()) {
-                            obj->set_context(*this);
-                        }
-                        for (auto& obj : registry->u_all_objects()) {
-                            obj->u_onLoaded();
-                        }
-                    }
-
-                    u_applyUpdates(hdr.updateVersion);
-                    u_postLoadMaintenance(hdr.updateVersion);
-                }
-                catch (const std::exception& exc) {
-                    _FATALERROR("caught exception (%s) during archive load - '%s'",
-                        typeid(exc).name(), exc.what());
-                    u_clearState();
-
-                    // force whole app to crash
-                    jc_assert(false);
-                }
-                catch (...) {
-                    _FATALERROR("caught unknown (non std::*) exception");
-                    u_clearState();
-
-                    // force whole app to crash
-                    jc_assert(false);
-                }
-            }
-
-            u_print_stats();
-        }
-        aqueue->start();
+    template<>
+    void object_context::load(boost::archive::binary_iarchive & ar, unsigned int version) {
+        ar >> *registry >> *aqueue;
     }
 
-    std::string object_context::write_to_string() {
-        std::ostringstream stream;
-        write_to_stream(stream);
-        return stream.str();
+    template<>
+    void object_context::save(boost::archive::binary_oarchive & ar, unsigned int version) const {
+        ar << *registry << *aqueue;
     }
 
-
-    template<class T>
-    std::string serialize_g(const char* str) {
-        std::stringstream stream;
-        boost::archive::binary_oarchive arch(stream);
-        arch << T(str);
-        return stream.str();
-    }
-
-    TEST(idiioti,_)
-    {
-        
-        auto toto = "kill me!";
-        auto s1 = serialize_g<std::string>(toto);
-        auto s2 = serialize_g<util::istring>(toto);
-    }
-
-    void object_context::write_to_stream(std::ostream& stream) {
-
-        stream.flags(stream.flags() | std::ios::binary);
-
-        header::write_to_stream(stream);
-
-        aqueue->stop();
-        {
-            boost::archive::binary_oarchive arch(stream);
-            arch << *registry;
-            arch << *aqueue;
-            boost::serialization::save_atomic(arch, _root_object_id);
-
-            u_print_stats();
-        }
-        aqueue->start();
+    template<>
+    void object_context::load_data_in_old_way(boost::archive::binary_iarchive& ar) {
+        ar >> *registry >> *aqueue;
     }
 
     void object_context::u_print_stats() const {
-        _DMESSAGE("%lu objects total", registry->u_all_objects().size());
-        _DMESSAGE("%lu public objects", registry->u_public_object_count());
-        _DMESSAGE("%lu objects in aqueue", aqueue->u_count());
+        JC_log("%lu objects total", registry->u_all_objects().size());
+        JC_log("%lu public objects", registry->u_public_object_count());
+        JC_log("%lu objects in aqueue", aqueue->u_count());
     }
 
     //////////////////////////////////////////////////////////////////////////
 
-    void object_context::u_applyUpdates(const serialization_version saveVersion) {
-        if (saveVersion <= serialization_version::pre_gc) {
-            if (auto db = root()) {
-                db->tes_retain();
-            }
+    void object_context::u_postLoadInitializations() {
+        for (auto& obj : registry->u_all_objects()) {
+            obj->set_context(*this);
+        }
+        for (auto& obj : registry->u_all_objects()) {
+            obj->u_onLoaded();
         }
     }
 
@@ -290,38 +126,10 @@ namespace collections
     {
         util::do_with_timing("Garbage collection", [&]() {
             auto res = garbage_collector::u_collect(*registry, *aqueue);
-            _DMESSAGE("%u garbage objects collected. %u objects are parts of cyclic graphs", res.garbage_total, res.part_of_graphs);
+            JC_log("%u garbage objects collected. %u objects are parts of cyclic graphs", res.garbage_total, res.part_of_graphs);
         });
     }
 
-    //////////////////////////////////////////////////////////////////////////
-
-    object_base* object_context::root() {
-        return getObject(_root_object_id);
-    }
-
-    void object_context::set_root(object_base *db) {
-        object_base * prev = getObject(_root_object_id);
-
-        if (prev == db) {
-            return;
-        }
-
-        if (db) {
-            //db->retain();
-            db->tes_retain(); // emulates a user-who-needs @root, this will prevent @db from being garbage collected
-        }
-
-        if (prev) {
-            //prev->release();
-            prev->tes_release();
-        }
-
-        _root_object_id = db ? db->uid() : HandleNull;
-    }
-
-    //////////////////////////////////////////////////////////////////////////
-
     void object_context::add_dependent_context(dependent_context& ctx) {
         spinlock::guard g(_dependent_contexts_mutex);
         if (std::find(_dependent_contexts.begin(), _dependent_contexts.end(), &ctx) == _dependent_contexts.end()) {
diff --git a/JContainers/src/object/object_module.cpp b/JContainers/src/object/object_module.cpp
index 3178863..9e7741f 100644
--- a/JContainers/src/object/object_module.cpp
+++ b/JContainers/src/object/object_module.cpp
@@ -9,9 +9,6 @@
 
 #include <jansson.h>
 
-#include <boost/iostreams/stream.hpp>
-#include <boost/iostreams/device/array.hpp>
-
 #include <boost/serialization/serialization.hpp>
 #include <boost/serialization/export.hpp>
 
@@ -34,6 +31,7 @@
 #include "rw_mutex.h"
 #include "gtest.h"
 
+#include "iarchive_with_blob.h"
 #include "jcontainers_constants.h"
 #include "object_base.h"
 #include "object_context.h"
diff --git a/JContainers/src/object/object_registry.h b/JContainers/src/object/object_registry.h
index 41e8fa7..5797ea9 100644
--- a/JContainers/src/object/object_registry.h
+++ b/JContainers/src/object/object_registry.h
@@ -7,7 +7,7 @@ namespace collections
     {
     public:
         typedef std::hash_set<object_base *> all_objects_set;
-        typedef std::hash_map<HandleT, object_base *> registry_container;
+        typedef std::hash_map<Handle, object_base *> registry_container;
 
     private:
 
@@ -35,15 +35,15 @@ namespace collections
             _all_objects.insert(&obj);
         }
 
-        void registerNewObjectId(object_base& obj) {
-            jc_assert(obj._uid() == HandleNull);
+        Handle registerNewObjectId(object_base& obj) {
+            //jc_assert(obj._uid() == Handle::Null);
 
             write_lock g(_mutex);
 
-            auto id = _idGen.new_id();
+            auto id = (Handle)_idGen.new_id();
             jc_assert(_map.find(id) == _map.end());
             _map.insert(registry_container::value_type(id, &obj));
-            obj._id = (Handle)id;
+            return id;
         }
 
         void removeObject(object_base& obj) {
@@ -53,9 +53,9 @@ namespace collections
 
         void u_removeObject(object_base& obj) {
             auto id = obj._uid();
-            if (id != HandleNull) {
+            if (id != Handle::Null) {
                 _map.erase(id);
-                _idGen.reuse_id(id);
+                _idGen.reuse_id((HandleT)id);
             }
 
             auto itr = _all_objects.find(&obj);
@@ -64,7 +64,7 @@ namespace collections
         }
 
         object_base *getObject(Handle hdl) const {
-            if (!hdl) {
+            if (hdl == Handle::Null) {
                 return nullptr;
             }
             
@@ -88,7 +88,7 @@ namespace collections
 
         object_stack_ref getObjectRef(Handle hdl) const {
             // had to copy&paste getObject function as we really must own an object BEFORE read lock will be released
-            if (!hdl) {
+            if (hdl == Handle::Null) {
                 return nullptr;
             }
             read_lock g(_mutex);
@@ -96,7 +96,7 @@ namespace collections
         }
 
         object_base *u_getObject(Handle hdl) const {
-            if (!hdl) {
+            if (hdl == Handle::Null) {
                 return nullptr;
             }
 
@@ -121,6 +121,11 @@ namespace collections
             return _map.size();
         }
 
+        size_t object_count() const {
+            read_lock guard(_mutex);
+            return _all_objects.size();
+        }
+
         friend class boost::serialization::access;
         BOOST_SERIALIZATION_SPLIT_MEMBER();
 
@@ -148,7 +153,7 @@ namespace collections
 
                 break;
             case 0: {
-                typedef std::map<HandleT, object_base *> registry_container_old;
+                typedef std::map<Handle, object_base *> registry_container_old;
                 registry_container_old oldCnt;
                 ar >> oldCnt >> _idGen;
 
diff --git a/JContainers/src/code_producer.hpp b/JContainers/src/reflection/detail/code_producer.hpp
similarity index 90%
rename from JContainers/src/code_producer.hpp
rename to JContainers/src/reflection/detail/code_producer.hpp
index 2490b71..fb952e8 100644
--- a/JContainers/src/code_producer.hpp
+++ b/JContainers/src/reflection/detail/code_producer.hpp
@@ -3,11 +3,12 @@
 #include <boost/filesystem/path.hpp>
 #include <assert.h>
 #include <vector>
+#include <fstream>
 
 #include "gtest.h"
-#include "reflection.h"
+#include "reflection/reflection.h"
 
-#include "tes_binding.h"
+#include "reflection/tes_binding.h"
 
 namespace reflection {
 
@@ -110,13 +111,8 @@ namespace reflection {
             p /= self.className().c_str();
             p += ".psc";
 
-            auto file = fopen(p.generic_string().c_str(), "w");
-            assert(file);
-            if (file) {
-                auto code = produceClassCode(self);
-                fwrite(code.c_str(), 1, code.length(), file);
-                fclose(file);
-            }
+            std::ofstream file(p.generic_string());
+            file << produceClassCode(self);
         }
 
     }
diff --git a/JContainers/src/reflection.cpp b/JContainers/src/reflection/detail/reflection.cpp
similarity index 75%
rename from JContainers/src/reflection.cpp
rename to JContainers/src/reflection/detail/reflection.cpp
index 997a911..6411db2 100644
--- a/JContainers/src/reflection.cpp
+++ b/JContainers/src/reflection/detail/reflection.cpp
@@ -1,17 +1,19 @@
-#include "reflection.h"
+#include "reflection/reflection.h"
 
 #include <map>
 #include "gtest.h"
 #include "util/spinlock.h"
+#include "util/singleton.h"
 #include "skse/PapyrusVM.h"
 
-#include "code_producer.hpp"
+#include "reflection/detail/code_producer.hpp"
+#include "reflection/detail/type_traits.hpp"
 
 namespace reflection {
 
-    void function_info::bind(VMClassRegistry *registry, const char *className) const {
-        registrator(registry, className, name.c_str());
-        registry->SetFunctionFlags(className, name.c_str(), VMClassRegistry::kFunctionFlag_NoWait);
+    void function_info::bind(VMClassRegistry& registry, const istring& className) const {
+        registrator(bind_args{ registry, className.c_str(), name.c_str() });
+        registry.SetFunctionFlags(className.c_str(), name.c_str(), VMClassRegistry::kFunctionFlag_NoWait);
     }
 
     static auto makeDB = []() {
@@ -32,12 +34,15 @@ namespace reflection {
         return classDB;
     };
 
-    static std::once_flag class_registry_once_flag;
-    static std::map<istring, class_info> class_registry_map;
+
+    static util::singleton<std::map<istring, class_info> > g_class_registry_map(
+        []() {
+            return new std::map<istring, class_info>{ makeDB() };
+        }
+    );
 
     const std::map<istring, class_info>& class_registry() {
-        std::call_once(class_registry_once_flag, []() { class_registry_map = makeDB(); });
-        return class_registry_map;
+        return g_class_registry_map.get();
     }
 
     const function_info* find_function_of_class(const char * functionName, const char *className) {
diff --git a/JContainers/src/reflection/detail/type_traits.hpp b/JContainers/src/reflection/detail/type_traits.hpp
new file mode 100644
index 0000000..458cf2b
--- /dev/null
+++ b/JContainers/src/reflection/detail/type_traits.hpp
@@ -0,0 +1,27 @@
+
+namespace reflection {  namespace binding {
+
+    template<>
+        function_parameter type_info<void>() { return function_parameter_make("void", nullptr); }
+
+    template<>
+        function_parameter type_info<bool>() { return function_parameter_make("bool", nullptr); }
+
+    template<>
+        function_parameter type_info<skse::string_ref>() { return function_parameter_make("string", nullptr); }
+
+    template<> 
+        function_parameter type_info< const char* >() { return function_parameter_make("string", nullptr); }
+
+    template<>
+        function_parameter type_info< Float32 >() { return function_parameter_make("float", nullptr); }
+    template<> 
+        function_parameter type_info< SInt32 >() { return function_parameter_make("int", nullptr); }
+    template<>
+        function_parameter type_info< UInt32 >() { return function_parameter_make("int", "this"); }
+    template<>
+        function_parameter type_info< TESForm * >() { return function_parameter_make("form", nullptr); }
+    template<>
+        function_parameter type_info< BGSListForm * >() { return function_parameter_make("FormList", nullptr); }
+}
+}
diff --git a/JContainers/src/reflection.h b/JContainers/src/reflection/reflection.h
similarity index 89%
rename from JContainers/src/reflection.h
rename to JContainers/src/reflection/reflection.h
index fa6d016..56081ee 100644
--- a/JContainers/src/reflection.h
+++ b/JContainers/src/reflection/reflection.h
@@ -29,9 +29,15 @@ namespace reflection {
     typedef void* tes_api_function;
     typedef void* c_function;
 
+    struct bind_args {
+        VMClassRegistry& registry;
+        const char* className;
+        const char* functionName;
+    };
+
     struct function_info {
         typedef std::string (*comment_generator)();
-        typedef  void (*tes_function_binder)(VMClassRegistry* registry, const char* className, const char* funcName);
+        typedef  void(*tes_function_binder)(const bind_args& args);
         typedef  std::vector<type_info_func> (*parameter_list_creator)();
 
         tes_function_binder registrator = nullptr;
@@ -65,14 +71,14 @@ namespace reflection {
             _comment_str = comment;
         }
 
-        void bind(VMClassRegistry *registry, const char *className) const;
+        void bind(VMClassRegistry& registry, const istring& className) const;
     };
 
     struct papyrus_text_block {
         typedef std::string(*text_generator)();
 
-        void set_text(const char * t) { _text = t; }
-        void set_text(text_generator t) { _text_generator_func = t; }
+        papyrus_text_block(const char * t) : _text(t) {}
+        papyrus_text_block(text_generator t) : _text_generator_func(t) {}
 
         const char * _text = nullptr;
         text_generator _text_generator_func = nullptr;
@@ -116,12 +122,12 @@ namespace reflection {
             methods.push_back(info);
         }
 
-        void bind(VMClassRegistry* registry) const {
+        void bind(VMClassRegistry& registry) const {
             assert(initialized());
 
             auto clsName = className();
             for (const auto& itm : methods) {
-                itm.bind(registry, clsName.c_str());
+                itm.bind(registry, clsName);
             }
         }
 
@@ -159,8 +165,6 @@ namespace reflection {
                 t.additionalSetup();
                 return t.metaInfo;
             }
-            // special support for hack inside REGISTERF macro
-            typedef T __Type;
         };
     }
     template <class T>
@@ -172,7 +176,7 @@ namespace reflection {
     const function_info* find_function_of_class(const char * functionName, const char *className);
 
     template<class T>
-    inline void foreach_metaInfo_do(T& func) {
+    inline void foreach_metaInfo_do(T&& func) {
 
         for (auto & pair : class_registry()) {
             func(pair.second);
diff --git a/JContainers/src/tes_binding.h b/JContainers/src/reflection/tes_binding.h
similarity index 14%
rename from JContainers/src/tes_binding.h
rename to JContainers/src/reflection/tes_binding.h
index 075e8d6..c4fe1b9 100644
--- a/JContainers/src/tes_binding.h
+++ b/JContainers/src/reflection/tes_binding.h
@@ -1,72 +1,75 @@
 #pragma once
 
 #include "skse/PapyrusNativeFunctions.h"
-#include "reflection.h"
-#include "skse_string.h"
+#include "skse/string.h"
+#include "reflection/reflection.h"
 
 class BGSListForm;
 
 namespace reflection { namespace binding {
 
     // traits placeholders
-    template<class TesType>
-    struct ValueConverter {
-        typedef TesType tes_type;
+    template<class JType>
+    struct IdentityConverter {
+        typedef JType tes_type;
 
-        static TesType convert2J(const TesType& val) {
+        static const tes_type& convert2J(const tes_type& val) {
             return val;
         }
 
-        static TesType convert2Tes(const TesType& val) {
+        static const tes_type& convert2Tes(const tes_type& val) {
             return val;
         }
     };
 
+    template<class JType, class TesType>
+    struct StaticCastValueConverter {
+        typedef TesType tes_type;
+
+        static JType convert2J(const TesType& val) {
+            return static_cast<JType>(val);
+        }
+
+        static TesType convert2Tes(const JType& val) {
+            return static_cast<TesType>(val);
+        }
+    };
+
     struct StringConverter {
-        typedef skse::string_ref tes_type;
+        using tes_type = skse::string_ref;
 
         static const char* convert2J(const skse::string_ref& str) {
             return str.c_str();
         }
 
-        static skse::string_ref convert2Tes(const char * str) {
+        template<class AnyString>
+        static skse::string_ref convert2Tes(const AnyString& str) {
             return skse::string_ref(str);
         }
     };
 
-    template<class JType> struct GetConv : ValueConverter < JType > {
+    template<class JType> struct GetConv : IdentityConverter < JType > {
         //typedef ValueConverter<TesType> Conv;
     };
 
+    template<> struct GetConv<void> {
+        using tes_type = void;
+    };
 
     template<> struct GetConv<const char*> : StringConverter{};
+    template<> struct GetConv<std::string> : StringConverter{};
+
+    template<> struct GetConv<int32_t> : StaticCastValueConverter<int32_t, SInt32>{};
 
     //////////////////////////////////////////////////////////////////////////
 
-    template<class T> struct j2Str {
-        static function_parameter typeInfo() { return function_parameter_make(typeid(T).name(), nullptr); }
-    };
+    template<class T>
+    function_parameter type_info();
 
-    template<> struct j2Str < skse::string_ref > {
-        static function_parameter typeInfo() { return function_parameter_make("string", nullptr); }
-    };
-    template<> struct j2Str < const char* > {
-        static function_parameter typeInfo() { return function_parameter_make("string", nullptr); }
-    };
-    template<> struct j2Str < Float32 > {
-        static function_parameter typeInfo() { return function_parameter_make("float", nullptr); }
-    };
-    template<> struct j2Str < SInt32 > {
-        static function_parameter typeInfo() { return function_parameter_make("int", nullptr); }
-    };
-    template<> struct j2Str < UInt32 > {
-        static function_parameter typeInfo() { return function_parameter_make("int", nullptr); }
-    };
-    template<> struct j2Str < TESForm * > {
-        static function_parameter typeInfo() { return function_parameter_make("form", nullptr); }
-    };
-    template<> struct j2Str < BGSListForm * > {
-        static function_parameter typeInfo() { return function_parameter_make("FormList", nullptr); }
+    template<class T> struct j2Str {
+        static function_parameter typeInfo() {
+            return reflection::binding::type_info<T>();
+        }
     };
 
     template<class T> struct j2Str < VMArray<T> > {
@@ -82,162 +85,102 @@ namespace reflection { namespace binding {
 
     //////////////////////////////////////////////////////////////////////////
 
-    template <typename T, T func> struct proxy;
+    template <typename T> struct proxy;
 
-    template <class R, class Arg0, class Arg1, R (*func)( Arg0, Arg1 ) >
-    struct proxy<R (*)(Arg0, Arg1), func>
-    {
-        typedef R return_type;
-        static std::vector<type_info_func> type_strings() {
-            type_info_func types[] = {
-                &j2Str<R>::typeInfo,
-                &j2Str<Arg0>::typeInfo,
-                &j2Str<Arg1>::typeInfo,
-            };
-            return std::vector<type_info_func>(&types[0], &types[0] + sizeof(types)/sizeof(type_info_func));
-        }
 
-        static typename GetConv<R>::tes_type tes_func(
-            StaticFunctionTag* tag,
-            typename GetConv<Arg0>::tes_type a0,
-            typename GetConv<Arg1>::tes_type a1)
-        {
-            return GetConv<R>::convert2Tes(
-                func(
-                    GetConv<Arg0>::convert2J(a0),
-                    GetConv<Arg1>::convert2J(a1))
-            );
-        }
+    template<size_t ParamCnt>
+    struct native_function_selector;
 
-        static void bind(VMClassRegistry *registry, const char *className, const char *name) {
-            registry->RegisterFunction(
-                new NativeFunction2 <
-                        StaticFunctionTag,
-                        typename GetConv<R>::tes_type,
-                        typename GetConv<Arg0>::tes_type,
-                        typename GetConv<Arg1>::tes_type >(name, className, &tes_func, registry)
-            );
-        }
+#define MAKE_ME_HAPPY(N)\
+    template<> struct native_function_selector<N> {\
+        template<class... Params> using function = ::NativeFunction ## N <::StaticFunctionTag, Params...>;\
     };
 
-    template <class Arg0, class Arg1, void (*func)( Arg0, Arg1 ) >
-    struct proxy<void (*)(Arg0, Arg1), func>
+    MAKE_ME_HAPPY(0);
+    MAKE_ME_HAPPY(1);
+    MAKE_ME_HAPPY(2);
+    MAKE_ME_HAPPY(3);
+    MAKE_ME_HAPPY(4);
+    MAKE_ME_HAPPY(5);
+    MAKE_ME_HAPPY(6);
+
+#undef  MAKE_ME_HAPPY
+
+    template<class T>
+    using remove_cref = typename std::remove_const<typename std::remove_reference<T>::type>::type;
+
+    template<class T>
+    using get_converter = GetConv< remove_cref<T> >;
+
+    template<class T>
+    using get_converter_tes_type = typename get_converter<T>::tes_type;
+
+
+    template <class R, class... Params>
+    struct proxy<R (*)(Params ...)>
     {
-        typedef void return_type;
-        static std::vector<type_info_func> type_strings() {
-            type_info_func types[] = {
-                &j2Str<void>::typeInfo,
-                &j2Str<Arg0>::typeInfo,
-                &j2Str<Arg1>::typeInfo,
+        static std::vector<type_info_func> parameter_info() {
+            return {
+                &j2Str< get_converter_tes_type<R> >::typeInfo,
+                &j2Str< get_converter_tes_type<Params> >::typeInfo ...
             };
-            return std::vector<type_info_func>(&types[0], &types[0] + sizeof(types)/sizeof(type_info_func));
         }
 
-        static void tes_func(
-            StaticFunctionTag* tag,
-            typename GetConv<Arg0>::tes_type a0,
-            typename GetConv<Arg1>::tes_type a1)
-        {
-            func(GetConv<Arg0>::convert2J(a0),
-                    GetConv<Arg1>::convert2J(a1));
-        }
+        using return_type = R;
 
-        static void bind(VMClassRegistry *registry, const char *className, const char *name) {
+        template< R(*func)(Params ...) >
+        struct magick {
 
-            registry->RegisterFunction(
-                new NativeFunction2 <
-                StaticFunctionTag,
-                void,
-                typename GetConv<Arg0>::tes_type,
-                typename GetConv<Arg1>::tes_type >(name, className, &tes_func, registry)
-                );
-        }
-    };
+            using base = proxy;
 
-    #define TARGS_NTH(n)            class Arg ## n
-    #define PARAM_NTH(n)            Arg##n arg##n
-    #define PARAM_NAMELESS_NTH(n)    Arg##n
-    #define ARG_NTH(n)              a##n
-    #define COMA                    ,
-
-    #define TESTYPE_NTH(n)          typename GetConv<Arg##n>::tes_type
-    #define TESPARAM_NTH(n)     TESTYPE_NTH(n) a##n
-    #define TESPARAM_CONV_NTH(n)     GetConv<Arg##n>::convert2J(a##n)
-    #define TYPESTRING_NTH(n)     &j2Str<Arg##n>::typeInfo
-
-
-    #define MAKE_PROXY_NTH(N) \
-        template <class R DO_##N(TARGS_NTH, COMA, COMA, NOTHING), R (*func)( DO_##N(PARAM_NAMELESS_NTH, NOTHING, COMA, NOTHING) ) >     \
-        struct proxy<R (*)(DO_##N(PARAM_NAMELESS_NTH, NOTHING, COMA, NOTHING)), func>     \
-            {     \
-            typedef R return_type; \
-            static std::vector<type_info_func> type_strings() {\
-                type_info_func types[] = {\
-                    &j2Str<R>::typeInfo,\
-                    DO_##N(TYPESTRING_NTH, NOTHING, COMA, NOTHING)\
-                };\
-                return std::vector<type_info_func>(&types[0], &types[0] + sizeof(types)/sizeof(type_info_func));\
-            }\
-            \
-            static typename GetConv<R>::tes_type tes_func(     \
-                StaticFunctionTag* tag     \
-                DO_##N(TESPARAM_NTH, COMA, COMA, NOTHING))     \
-            {     \
-                return GetConv<R>::convert2Tes(func(\
-                    DO_##N(TESPARAM_CONV_NTH, NOTHING, COMA, NOTHING)   \
-                ));     \
-            }     \
-                 \
-            static void bind(VMClassRegistry *registry, const char *className, const char *name) {     \
-                registry->RegisterFunction(     \
-                    new NativeFunction##N <StaticFunctionTag, typename GetConv<R>::tes_type   \
-                        DO_##N(TESTYPE_NTH, COMA, COMA, NOTHING)  > (name, className, &tes_func, registry)   \
-                );     \
-            }     \
-        };  \
-            \
-        template <DO_##N(TARGS_NTH, NOTHING, COMA, COMA) void (*func)( DO_##N(PARAM_NAMELESS_NTH, NOTHING, COMA, NOTHING) ) >     \
-        struct proxy<void (*)(DO_##N(PARAM_NAMELESS_NTH, NOTHING, COMA, NOTHING)), func>     \
-        {     \
-            typedef void return_type; \
-            static std::vector<type_info_func> type_strings() {\
-                type_info_func types[] = {\
-                    &j2Str<void>::typeInfo,\
-                    DO_##N(TYPESTRING_NTH, NOTHING, COMA, NOTHING)\
-                };\
-                return std::vector<type_info_func>(&types[0], &types[0] + sizeof(types)/sizeof(type_info_func));\
-            }\
-            \
-            static void tes_func(     \
-                StaticFunctionTag* tag     \
-                DO_##N(TESPARAM_NTH, COMA, COMA, NOTHING))     \
-            {     \
-                func(DO_##N(TESPARAM_CONV_NTH, NOTHING, COMA, NOTHING));     \
-            }     \
-                 \
-            static void bind(VMClassRegistry *registry, const char *className, const char *name) {     \
-                registry->RegisterFunction(     \
-                    new NativeFunction##N <StaticFunctionTag, void   \
-                        DO_##N(TESTYPE_NTH, COMA, COMA, NOTHING)  > (name, className, tes_func, registry)   \
-                );     \
-            }     \
-        };
+            static auto func_ptr() -> decltype(func) {
+                return func;
+            }
 
-#define NOTHING 
+            struct non_void_ret {
+                static get_converter_tes_type<R> tes_func(
+                    StaticFunctionTag* tag,
+                    get_converter_tes_type<Params> ... params)
+                {
+                    return GetConv<R>::convert2Tes(
+                        func(
+                            get_converter<Params>::convert2J(params) ...
+                        )
+                    );
+                }
+            };
 
-#define DO_0(rep, f, m, l)
-#define DO_1(rep, f, m_, l)   f rep(1) l
-#define DO_2(rep, f, m, l)   DO_1(rep, f, m, NOTHING) m  rep(2) l
-#define DO_3(rep, f, m, l)   DO_2(rep, f, m, NOTHING) m  rep(3) l
-#define DO_4(rep, f, m, l)   DO_3(rep, f, m, NOTHING) m  rep(4) l
-#define DO_5(rep, f, m, l)   DO_4(rep, f, m, NOTHING) m  rep(5) l
+            struct void_ret {
+                static void tes_func(
+                    StaticFunctionTag* tag,
+                    get_converter_tes_type<Params> ... params)
+                {
+                    func(get_converter<Params>::convert2J(params) ...);
+                }
+            };
 
+            using tes_func_holder = typename std::conditional<
+                std::is_void<R>::value,
+                typename void_ret,
+                typename non_void_ret>::type;
+
+            static void bind(const bind_args& args) {
+                args.registry.RegisterFunction
+                (
+                    new typename native_function_selector<sizeof...(Params)>::function<
+                        get_converter_tes_type<R>, get_converter_tes_type<Params> ...>
+                        (
+                            args.functionName,
+                            args.className,
+                            &tes_func_holder::tes_func,
+                            &args.registry
+                        )
+                );
+            }
+        };
 
-    MAKE_PROXY_NTH(0);
-    MAKE_PROXY_NTH(1);
-    //MAKE_PROXY_NTH(2);
-    MAKE_PROXY_NTH(3);
-    MAKE_PROXY_NTH(4);
+
+    };
 
 #define CONCAT(x, y) CONCAT1 (x, y)
 #define CONCAT1(x, y) x##y
@@ -245,53 +188,56 @@ namespace reflection { namespace binding {
     // MSVC2012 bug workaround
     template <typename T> T msvc_identity(T);
 
-    // retrieves class_info pointer from member address
-    // specially for hack made in REGISTERF macro
-    inline class_info& metaInfoFromFieldAndOffset(void * fieldAddress, int offset) {
-        auto mixin = (_detail::class_meta_mixin *)((char *)fieldAddress - offset);
-        return mixin->metaInfo;
-    }
-
-#define REGISTER_TES_NAME(ScriptTesName)\
-    struct CONCAT(_struct_, __LINE__) {\
-        CONCAT(_struct_, __LINE__)() {\
-            using namespace reflection;\
-            auto& mInfo = binding::metaInfoFromFieldAndOffset( this, offsetof(__Type, CONCAT(_mem_, __LINE__)) );\
-            mInfo._className = (ScriptTesName);\
-            }\
-        } CONCAT(_mem_, __LINE__);
+    struct name_setter {
+        explicit name_setter(class_info& info, const char* className) {
+            info._className = className;
+        }
+    };
+
+#define REGISTER_TES_NAME(ScriptTesName)  \
+    ::reflection::binding::name_setter _name_setter{ metaInfo, ScriptTesName };
+
+    struct function_registree {
+
+        template<class Binder, class String2>
+        inline function_registree(class_info& info,
+            Binder,
+            const char* funcname, const char* argument_names, const String2& comment)
+        {
+            using namespace ::reflection;
+
+            static_assert( false == std::is_same<Binder::base::return_type, const char *>::value, "a trap for 'const char *' return types" );
+
+            function_info metaF;
+            metaF.registrator = &Binder::bind;
+            metaF.param_list_func = &Binder::base::parameter_info;
+             
+            metaF.argument_names = (argument_names) ? (argument_names) : "";
+            metaF.setComment(comment);
+            metaF.name = funcname;
+            metaF.tes_func = &Binder::tes_func_holder::tes_func;
+            metaF.c_func = static_cast<c_function>(Binder::func_ptr());
+
+            info.addFunction(metaF);
+        }
+    };
 
 #define REGISTERF(func, _funcname, _args, _comment)\
-    struct CONCAT(_struct_, __LINE__) {\
-         CONCAT(_struct_, __LINE__)() {\
-             using namespace reflection;\
-             function_info metaF;\
-             typedef binding::proxy<decltype(binding::msvc_identity(&(func))), &(func)> binder;\
-             static_assert( false == std::is_same<binder::return_type, const char *>::value, "a trap for const char * return types" ); \
-             metaF.registrator = &binder::bind;\
-             metaF.param_list_func = &binder::type_strings;\
-             \
-             metaF.argument_names = (_args) ? (_args) : ""; \
-             metaF.setComment(_comment);\
-             metaF.name = (_funcname) ? (_funcname) : ""; \
-             metaF.tes_func = &binder::tes_func;\
-             auto addr = &(func);\
-             metaF.c_func = addr;\
-             binding::metaInfoFromFieldAndOffset(this, offsetof(__Type, CONCAT(_mem_, __LINE__))).addFunction(metaF);\
-         }\
-    } CONCAT(_mem_, __LINE__);
-
-#define REGISTER_TEXT(text)\
-    struct CONCAT(_struct_, __LINE__) {\
-         CONCAT(_struct_, __LINE__)() {\
-             using namespace reflection;\
-             papyrus_text_block tb;\
-             tb.set_text(text);\
-             binding::metaInfoFromFieldAndOffset(this, offsetof(__Type, CONCAT(_mem_, __LINE__))).add_text_block(tb); \
-        }\
-    } CONCAT(_mem_, __LINE__);
+    ::reflection::binding::function_registree CONCAT(_func_registree_, __LINE__){ metaInfo,\
+        ::reflection::binding::proxy<decltype(::reflection::binding::msvc_identity(&func))>::magick<&func>(), \
+        _funcname, _args, _comment };
 
 #define REGISTERF2(func, args, comment)     REGISTERF(func, #func, args, comment)
 
+    struct papyrus_textblock_setter {
+        explicit papyrus_textblock_setter(class_info& info, const papyrus_text_block& text) {
+            info.add_text_block(text);
+        }
+    };
+
+#define REGISTER_TEXT(text) \
+    ::reflection::binding::papyrus_textblock_setter CONCAT(_textblock_setter_, __LINE__){ metaInfo, ::reflection::papyrus_text_block(text) };
+
+
 }
 }
diff --git a/JContainers/src/skse_papyrus_args.hpp b/JContainers/src/skse/papyrus_args.hpp
similarity index 97%
rename from JContainers/src/skse_papyrus_args.hpp
rename to JContainers/src/skse/papyrus_args.hpp
index 62f9623..020fbd2 100644
--- a/JContainers/src/skse_papyrus_args.hpp
+++ b/JContainers/src/skse/papyrus_args.hpp
@@ -1,7 +1,7 @@
 #pragma once
 
 #include "skse/PapyrusArgs.h"
-#include "skse_string.h"
+#include "skse/string.h"
 
 template <> inline UInt32 GetTypeID <skse::string_ref>(VMClassRegistry * registry)                        { return VMValue::kType_String; }
 template <> inline UInt32 GetTypeID <VMArray<skse::string_ref>>(VMClassRegistry * registry)       { return VMValue::kType_StringArray; }
diff --git a/JContainers/src/skse.cpp b/JContainers/src/skse/skse.cpp
similarity index 11%
rename from JContainers/src/skse.cpp
rename to JContainers/src/skse/skse.cpp
index 63601d9..cf724ca 100644
--- a/JContainers/src/skse.cpp
+++ b/JContainers/src/skse/skse.cpp
@@ -1,4 +1,4 @@
-#include "skse.h"
+#include "skse/skse.h"
 
 
 //#include <boost/iostreams/stream.hpp>
@@ -12,124 +12,207 @@
 #include "skse/GameData.h"
 #include "skse/InternalSerialization.h"
 #include "skse/PluginAPI.h"
+#include "skse/PapyrusVM.h"
 
+#include "util/stl_ext.h"
 #include "gtest.h"
+
+#include "collections/form_handling.h"
 //#include "util/util.h"
 //#include "jc_interface.h"
-//#include "reflection.h"
+//#include "reflection/reflection.h"
 //#include "jcontainers_constants.h"
-//#include "tes_context.h"
-
+//#include "collections/tes_context.h"
 
-extern SKSESerializationInterface* g_serialization;
+extern SKSESerializationInterface	* g_serialization;
 
 namespace skse {
 
-    static bool _is_fake = true;
+    namespace {
+        struct skse_api {
+            virtual const char * modname_from_index(uint8_t idx) = 0;
+            virtual uint8_t modindex_from_name(const char * name) = 0;
 
-    namespace fake_skse {
+            virtual FormId resolve_handle(FormId handle) = 0;
+            virtual TESForm* lookup_form(FormId handle) = 0;
 
-        enum {
-            char_count = 'Z' - 'A' + 1,
+            virtual bool try_retain_handle(FormId handle) = 0;
+            virtual void release_handle(FormId handle) = 0;
 
+            virtual void console_print(const char * fmt, const va_list& args) = 0;
         };
 
-        static char fakePluginNames[char_count * 2];
+        namespace fake_skse {
 
-        static bool index_in_range(int idx) {
-            return idx >= 'A' && idx <= 'Z';
-        }
+            enum {
+                char_count = 'Z' - 'A' + 1,
 
-        uint8_t wrap_index(int idx) {
-            int rel = (int)idx - (int)'A';
-            int wrapped = rel >= 0 ? rel % char_count : (-rel) % char_count;
-            assert(wrapped >= 0 && wrapped < char_count);
-            return wrapped;
-        }
+            };
 
-        const char * modname_from_index(uint8_t idx) {
+            static char fakePluginNames[char_count * 2];
 
-            if (index_in_range(idx)) {
-                int wrapped = wrap_index(idx);
-                fakePluginNames[wrapped*2] = (char)('A' + wrapped);
-                fakePluginNames[wrapped*2 + 1] = '\0';
-                return &fakePluginNames[wrapped * 2];
+            static bool index_in_range(int idx) {
+                return idx >= 'A' && idx <= 'Z';
             }
-            else {
-                return nullptr;
+
+            uint8_t wrap_index(int idx) {
+                int rel = (int)idx - (int)'A';
+                int wrapped = rel >= 0 ? rel % char_count : (-rel) % char_count;
+                assert(wrapped >= 0 && wrapped < char_count);
+                return wrapped;
             }
-         }
 
-        uint8_t modindex_from_name(const char * name) {
-            assert(name);
-            return index_in_range(*name) ? *name : 0xFF;
-        }
+            const char * modname_from_index(uint8_t idx) {
+
+                if (index_in_range(idx)) {
+                    int wrapped = wrap_index(idx);
+                    fakePluginNames[wrapped * 2] = (char)('A' + wrapped);
+                    fakePluginNames[wrapped * 2 + 1] = '\0';
+                    return &fakePluginNames[wrapped * 2];
+                }
+                else {
+                    return nullptr;
+                }
+            }
 
-        TEST(modname_from_index, test)
-        {
-            auto res = modname_from_index('Z');
-            EXPECT_TRUE( strcmp(res, "Z") == 0 );
+            uint8_t modindex_from_name(const char * name) {
+                assert(name);
+                return index_in_range(*name) ? *name : 0xFF;
+            }
+
+            TEST(modname_from_index, test)
+            {
+                auto res = modname_from_index('Z');
+                EXPECT_TRUE(strcmp(res, "Z") == 0);
 
-            EXPECT_TRUE(modindex_from_name("Action") == 'A');
+                EXPECT_TRUE(modindex_from_name("Action") == 'A');
 
-            EXPECT_NIL(modname_from_index('|'));
-            EXPECT_NIL(modname_from_index('a'));
+                EXPECT_NIL(modname_from_index('|'));
+                EXPECT_NIL(modname_from_index('a'));
+            }
         }
-    }
 
-    uint32_t resolve_handle(uint32_t handle) {
-        if (!is_fake()) {
-            UInt8	modID = handle >> 24;
+        struct skse_fake_api : skse_api {
+            const char * modname_from_index(uint8_t idx) override {
+                return fake_skse::modname_from_index(idx);
+            }
+
+            uint8_t modindex_from_name(const char * name) override {
+                return fake_skse::modindex_from_name(name);
+            }
 
-            // should not have been saved anyway?
-            if (modID == 0xFF)
+            FormId resolve_handle(FormId handle) override {
                 return handle;
+            }
 
-            UInt64 handleOut = 0;
-            return g_serialization->ResolveHandle(handle, &handleOut) ? (uint32_t)handleOut : 0;
-        }
+            TESForm* lookup_form(FormId handle) override {
+                // Just a blob of bytes which imitates TESForm
+                static char fakeTesForm[sizeof TESForm] = { '\0' };
+                return reinterpret_cast<TESForm*>(&fakeTesForm);
+            }
 
-        return handle;
-    }
+            bool try_retain_handle(FormId handle) override { return true; }
+            void release_handle(FormId handle) override {}
 
-    const char * modname_from_index(uint8_t idx) {
-        if (!is_fake()) {
-            DataHandler * dhand = DataHandler::GetSingleton();
-            ModInfo * modInfo = idx < _countof(dhand->modList.loadedMods) ? dhand->modList.loadedMods[idx] : nullptr;
-            return modInfo ? modInfo->name : nullptr;
-        }
-        else {
-            return fake_skse::modname_from_index(idx);
-        }
+            void console_print(const char * fmt, const va_list& args) override {
+/*
+                printf("Fake Console: ");
+                vprintf_s(fmt, args);
+                printf("\n");*/
+            }
+        };
+
+        struct skse_silent_api : skse_api {
+            const char * modname_from_index(uint8_t idx) override { return ""; }
+            uint8_t modindex_from_name(const char * name) override { return 0; }
+            FormId resolve_handle(FormId handle) override { return FormId::Zero; }
+            TESForm* lookup_form(FormId handle) override { return nullptr; }
+            bool try_retain_handle(FormId handle) override { return true; }
+            void release_handle(FormId handle) override {}
+            void console_print(const char * fmt, const va_list& args) override {}
+        };
+
+        struct skse_real_api : skse_api {
+            const char * modname_from_index(uint8_t idx) override {
+                DataHandler * dhand = DataHandler::GetSingleton();
+                ModInfo * modInfo = idx < _countof(dhand->modList.loadedMods) ? dhand->modList.loadedMods[idx] : nullptr;
+                return modInfo ? modInfo->name : nullptr;
+            }
+
+            uint8_t modindex_from_name(const char * name) override {
+                return DataHandler::GetSingleton()->GetModIndex(name);
+            }
+
+            FormId resolve_handle(FormId handle) override {
+                if ((util::to_integral(handle) >> 24) == 0xFF) { // dynamic form - return untouched
+                    return handle;
+                }
+
+                UInt64 handleOut = 0;
+                return g_serialization->ResolveHandle(util::to_integral(handle), &handleOut) ? (FormId)handleOut : FormId::Zero;
+            }
+
+            TESForm* lookup_form(FormId handle) override {
+                return LookupFormByID(util::to_integral(handle));
+            }
+
+            bool try_retain_handle(FormId id) override {
+                auto handle = util::to_integral(collections::form_handling::form_id_to_handle(id));
+                TESForm* form = reinterpret_cast<TESForm*>((*g_objectHandlePolicy)->Resolve(TESForm::kTypeID, handle));
+                if (form) {
+                    (*g_objectHandlePolicy)->AddRef(handle);
+                    return true;
+                }
+                return false;
+            }
+            void release_handle(FormId handle) override {
+                (*g_objectHandlePolicy)->Release(util::to_integral(collections::form_handling::form_id_to_handle(handle)));
+            }
+
+            void console_print(const char * fmt, const va_list& args) override {
+                ConsoleManager	* mgr = ConsoleManager::GetSingleton();
+                if (mgr) {
+                    CALL_MEMBER_FN(mgr, Print)(fmt, args);
+                }
+            }
+        };
+
+        skse_fake_api g_fake_api;
+        skse_real_api g_real_api;
+        skse_silent_api g_silent_api;
+
+        skse_api* g_current_api = &g_fake_api;
     }
 
-    uint8_t modindex_from_name(const char * name) {
-        return !is_fake() ? DataHandler::GetSingleton()->GetModIndex(name) : fake_skse::modindex_from_name(name);
+
+    void set_real_api() {
+        g_current_api = &g_real_api;
+    }
+    void set_fake_api() {
+        g_current_api = &g_fake_api;
+    }
+    void set_silent_api() {
+        g_current_api = &g_silent_api;
     }
 
-    // A fake form. Made for imitating SKSE during synthetic tests
-    static char fakeTesForm[sizeof TESForm];
+    FormId resolve_handle(FormId handle) {
+        return g_current_api->resolve_handle(handle);
+    }
 
-    TESForm* lookup_form(uint32_t handle) {
-        return !is_fake() ? LookupFormByID(handle) : reinterpret_cast<TESForm*>(&fakeTesForm);
+    TESForm* lookup_form(FormId handle) {
+        return handle != FormId::Zero ? g_current_api->lookup_form(handle) : nullptr;
     }
 
-    bool is_fake() {
-        return _is_fake;
+    const char * modname_from_index(uint8_t idx) {
+        return g_current_api->modname_from_index(idx);
     }
 
-    void set_no_fake() {
-        _is_fake = false;
+    uint8_t modindex_from_name(const char * name) {
+        return g_current_api->modindex_from_name(name);
     }
 
     void console_print(const char * fmt, const va_list& args) {
-        if (is_fake()) {
-            return;
-        }
-        ConsoleManager	* mgr = ConsoleManager::GetSingleton();
-        if (mgr) {
-            CALL_MEMBER_FN(mgr, Print)(fmt, args);
-        }
+        g_current_api->console_print(fmt, args);
     }
 
     void console_print(const char * fmt, ...) {
@@ -138,4 +221,13 @@ namespace skse {
         console_print(fmt, args);
         va_end(args);
     }
+
+    bool try_retain_handle(FormId handle) {
+        return g_current_api->try_retain_handle(handle);
+    }
+
+    void release_handle(FormId handle) {
+        g_current_api->release_handle(handle);
+    }
+
 }
diff --git a/JContainers/src/skse.h b/JContainers/src/skse/skse.h
similarity index 52%
rename from JContainers/src/skse.h
rename to JContainers/src/skse/skse.h
index f3137ab..ddecb20 100644
--- a/JContainers/src/skse.h
+++ b/JContainers/src/skse/skse.h
@@ -1,20 +1,32 @@
 #pragma once
 
 #include <stdint.h>
+#include "form_id.h"
 
 class TESForm;
 
 // Wraps calls to SKSE. Fakes the calls when SKSE/Skyrim inactive (during synthetic tests)
 namespace skse {
+
+    namespace {
+        using collections::FormId;
+        using collections::FormIdUnredlying;
+    }
+
     // pass static form ids here only
     const char * modname_from_index(uint8_t idx);
     uint8_t modindex_from_name(const char * name);
 
-    uint32_t resolve_handle(uint32_t handle);
-    TESForm* lookup_form(uint32_t handle);
+    FormId resolve_handle(FormId handle);
+    TESForm* lookup_form(FormId handle);
+
+    bool try_retain_handle(FormId handle);
+    void release_handle(FormId handle);
 
-    bool is_fake();
-    void set_no_fake();
     void console_print(const char * fmt, ...);
     void console_print(const char * fmt, const va_list& args);
+
+    void set_real_api();
+    void set_fake_api();
+    void set_silent_api();
 }
diff --git a/JContainers/src/skse_string.h b/JContainers/src/skse/string.h
similarity index 96%
rename from JContainers/src/skse_string.h
rename to JContainers/src/skse/string.h
index d95fc56..668ceb8 100644
--- a/JContainers/src/skse_string.h
+++ b/JContainers/src/skse/string.h
@@ -69,7 +69,6 @@ namespace skse {
         }
 
         bool operator==(const string_ref& lhs) const { return data == lhs.data; }
-        //bool operator<(const sting_ref& lhs) const { return data < lhs.data; }
 
         const char* c_str() const {
             return data;
diff --git a/JContainers/src/skse_api.cpp b/JContainers/src/skse_callbacks.cpp
similarity index 79%
rename from JContainers/src/skse_api.cpp
rename to JContainers/src/skse_callbacks.cpp
index 86abe0a..462b4e6 100644
--- a/JContainers/src/skse_api.cpp
+++ b/JContainers/src/skse_callbacks.cpp
@@ -9,12 +9,14 @@
 #include "skse/GameData.h"
 
 //#include "gtest.h"
-#include "skse.h"
+#include "skse/skse.h"
 #include "util/util.h"
 #include "jc_interface.h"
-#include "reflection.h"
+#include "reflection/reflection.h"
 #include "jcontainers_constants.h"
-#include "tes_context.h"
+
+#include "collections/context.h"
+#include "collections/dyn_form_watcher.h"
 
 class VMClassRegistry;
 
@@ -23,6 +25,8 @@ namespace jc {
 }
 
 SKSESerializationInterface	* g_serialization = nullptr;
+static SKSEPapyrusInterface			* g_papyrus = nullptr;
+static SKSEMessagingInterface       * g_messaging = nullptr;
 
 namespace {
 
@@ -30,13 +34,11 @@ namespace {
 
     static PluginHandle					g_pluginHandle = kPluginHandle_Invalid;
 
-    static SKSEPapyrusInterface			* g_papyrus = nullptr;
-    static SKSEMessagingInterface       * g_messaging = nullptr;
-
-
     void revert(SKSESerializationInterface * intfc) {
         util::do_with_timing("Revert", []() {
+            skse::set_silent_api();
             collections::tes_context::instance().clearState();
+            skse::set_real_api();
         });
     }
 
@@ -64,7 +66,7 @@ namespace {
                 //_DMESSAGE("%lu bytes saved", stream.tellp());
             }
             else {
-                _DMESSAGE("Unable open JC record");
+                JC_log("Unable open JC record");
             }
         });
     }
@@ -90,6 +92,10 @@ namespace {
 
         util::do_with_timing("Load", [intfc]() {
 
+            skse::set_silent_api();
+            collections::tes_context::instance().clearState();
+            skse::set_real_api();
+
             UInt32 type = 0;
             UInt32 version = 0;
             UInt32 length = 0;
@@ -120,33 +126,33 @@ namespace {
             // store plugin handle so we can identify ourselves later
             g_pluginHandle = skse->GetPluginHandle();
 
-            _MESSAGE(JC_PLUGIN_NAME " " JC_VERSION_STR);
+            JC_log(JC_PLUGIN_NAME " " JC_VERSION_STR);
 
             if (skse->isEditor) {
-                _MESSAGE("loaded in editor, marking as incompatible");
+                JC_log("loaded in editor, marking as incompatible");
                 return false;
             }
             else if (skse->runtimeVersion != RUNTIME_VERSION_1_9_32_0) {
-                _MESSAGE("unsupported runtime version %08X", skse->runtimeVersion);
+                JC_log("unsupported runtime version %08X", skse->runtimeVersion);
                 return false;
             }
 
             // get the serialization interface and query its version
             g_serialization = (SKSESerializationInterface *)skse->QueryInterface(kInterface_Serialization);
             if (!g_serialization) {
-                _MESSAGE("couldn't get serialization interface");
+                JC_log("couldn't get serialization interface");
                 return false;
             }
 
             if (g_serialization->version < SKSESerializationInterface::kVersion) {
-                _MESSAGE("serialization interface too old (%d expected %d)", g_serialization->version, SKSESerializationInterface::kVersion);
+                JC_log("serialization interface too old (%d expected %d)", g_serialization->version, SKSESerializationInterface::kVersion);
                 return false;
             }
 
             g_papyrus = (SKSEPapyrusInterface *)skse->QueryInterface(kInterface_Papyrus);
 
             if (!g_papyrus) {
-                _MESSAGE("couldn't get papyrus interface");
+                JC_log("couldn't get papyrus interface");
                 return false;
             }
 
@@ -155,19 +161,18 @@ namespace {
                 g_messaging = messaging;
             }
 
-            skse::set_no_fake();
+            skse::set_real_api();
 
             return true;
         }
 
         bool registerAllFunctions(VMClassRegistry *registry) {
 
-            _MESSAGE("registering functions");
-
-            reflection::foreach_metaInfo_do([=](const reflection::class_info& info) {
-                info.bind(registry);
+            util::do_with_timing("Registering functions", [=]() {
+                reflection::foreach_metaInfo_do([=](const reflection::class_info& info) {
+                    info.bind(*registry);
+                });
             });
-
             return true;
         }
 
@@ -179,6 +184,11 @@ namespace {
             g_serialization->SetSaveCallback(g_pluginHandle, save);
             g_serialization->SetLoadCallback(g_pluginHandle, load);
 
+
+            g_serialization->SetFormDeleteCallback(g_pluginHandle, [](UInt64 handle) {
+                tes_context::instance()._form_watcher.on_form_deleted((FormHandle)handle);
+            });
+
             g_papyrus->Register(registerAllFunctions);
 
             if (g_messaging) {
@@ -189,7 +199,7 @@ namespace {
                 });
             }
 
-            _MESSAGE("plugin loaded");
+            JC_log("plugin loaded");
 
             return true;
         }
diff --git a/JContainers/src/testing_api.cpp b/JContainers/src/testing_api.cpp
index d3daa6b..d2e0104 100644
--- a/JContainers/src/testing_api.cpp
+++ b/JContainers/src/testing_api.cpp
@@ -1,5 +1,5 @@
 #include "jcontainers_constants.h"
-#include "reflection.h"
+#include "reflection/reflection.h"
 #include "gtest.h"
 
 // C API for python scripts as a part of bundling and testing functionality
@@ -19,7 +19,16 @@ extern "C" {
         });
     }
 
-    __declspec(dllexport) void JC_runTests() {
-        testing::runTests(meta<testing::TestInfo>::getListConst());
+    __declspec(dllexport) bool JC_runTests(int argc, const char** argv) {
+        using namespace std;
+
+        // @argv points to Python internal memory, it's best to keep things safe and copy it
+        const vector<string> args(argv, argv + argc);
+        vector<char*> char_ptr_args;
+        transform(args.begin(), args.end(), back_inserter(char_ptr_args),
+            [](const string& s) { return const_cast<char*>(s.c_str()); });
+
+        ::testing::InitGoogleTest(&argc, &char_ptr_args.front());
+        return RUN_ALL_TESTS() == 0;
     }
 }
diff --git a/JContainers/src/typedefs.h b/JContainers/src/typedefs.h
index c342e01..ffdd910 100644
--- a/JContainers/src/typedefs.h
+++ b/JContainers/src/typedefs.h
@@ -1,18 +1,32 @@
 #pragma once
 
 #include <assert.h>
+#include <type_traits>
 
 #   define STR(...)     __STR(__VA_ARGS__)
 #   define __STR(...)   #__VA_ARGS__
 
 #   define ARGS(...)    __VA_ARGS__
 
+extern void JC_log(const char * fmt, ...);
+extern void JC_log(const char* fmt, va_list& args);
+
 #   ifdef NO_JC_DEBUG
 #       define jc_assert(expr)
 #       define jc_debug(message, ...)
+#       define jc_assert_msg(expr, fmt, ...)
 #   else
-#       define jc_assert(expr)              if (!(expr)) { __debugbreak(); }
-#       define jc_debug(message, ...)       printf(message"\n", __VA_ARGS__);
+#       define jc_assert(expr)              do { if (!(expr)) { __debugbreak(); } } while(0)
+#       define jc_debug(message, ...)       do { printf(message"\n", __VA_ARGS__); } while(0)
+
+#       define jc_assert_msg(expr, fmt, ...)    \
+            do { \
+                if (!(expr)) { \
+                    JC_log(fmt, __VA_ARGS__); \
+                    assert(false && fmt); \
+                } \
+            } while(0)
+
 #   endif
 
 __declspec(noreturn) inline void noreturn_func() {}
diff --git a/JContainers/src/util/atomic_serialization.h b/JContainers/src/util/atomic_serialization.h
new file mode 100644
index 0000000..f684b87
--- /dev/null
+++ b/JContainers/src/util/atomic_serialization.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <atomic>
+
+namespace boost {
+    namespace serialization {
+
+        template<class Archive, class T>
+        inline void save_atomic(Archive& ar, const std::atomic<T>& v) {
+            T refCnt = v._My_val;
+            ar & refCnt;
+        }
+
+        template<class Archive, class T>
+        inline void load_atomic(Archive& ar, std::atomic<T> & v) {
+            T refCnt = (T)0;
+            ar & refCnt;
+            v._My_val = refCnt;
+        }
+    }
+}
diff --git a/JContainers/src/util/logging.cpp b/JContainers/src/util/logging.cpp
new file mode 100644
index 0000000..c91920c
--- /dev/null
+++ b/JContainers/src/util/logging.cpp
@@ -0,0 +1,20 @@
+#include "skse/skse.h"
+
+void JC_log(const char* fmt, va_list& args) {
+    va_list	args_copy;
+
+    va_copy(args_copy, args);
+
+    skse::console_print(fmt, args);
+    gLog.Log(IDebugLog::kLevel_Message, fmt, args_copy);
+
+    va_end(args_copy);
+}
+
+void JC_log(const char* fmt, ...) {
+    va_list	args;
+    va_start(args, fmt);
+    JC_log(fmt, args);
+    va_end(args);
+}
+
diff --git a/JContainers/src/util/singleton.h b/JContainers/src/util/singleton.h
new file mode 100644
index 0000000..652b4fe
--- /dev/null
+++ b/JContainers/src/util/singleton.h
@@ -0,0 +1,53 @@
+#pragma once
+
+#include <type_traits>
+#include <functional>
+#include "boost/assert.hpp"
+
+#include "util/spinlock.h"
+
+namespace util {
+
+    template<
+        class T,
+        // option to not destroy underlying object ->
+        // destructors may invoke some un-usable during exit C++ functions, like the ones that provide lock functionality,
+        // which may lead to crash at exit
+        bool destructorDestroys = true
+    >
+    struct singleton {
+        std::atomic<T*> _si = nullptr;
+        spinlock _lock;
+        std::function<T*()> _ctor;
+
+        singleton() = delete;
+        singleton& operator = (const singleton&) = delete;
+
+        template<class Creator>
+        explicit singleton(Creator&& ctor) : _ctor(std::forward<Creator>(ctor)) {}
+
+        ~singleton() {
+            if (destructorDestroys) {
+                delete _si.load(std::memory_order_relaxed);
+            }
+        }
+
+        T& get() {
+            T* tmp = _si.load(std::memory_order_acquire);
+            if (tmp == nullptr) {
+                spinlock::guard g(_lock);
+                tmp = _si.load(std::memory_order_relaxed);
+                if (tmp == nullptr) {
+                    tmp = _ctor();
+                    BOOST_ASSERT(tmp);
+                    _ctor = nullptr;
+                    _si.store(tmp, std::memory_order_release);
+                }
+            }
+
+            return *tmp;
+        }
+    };
+
+
+}
\ No newline at end of file
diff --git a/JContainers/src/util/stl_ext.h b/JContainers/src/util/stl_ext.h
new file mode 100644
index 0000000..4759638
--- /dev/null
+++ b/JContainers/src/util/stl_ext.h
@@ -0,0 +1,65 @@
+#pragma once
+
+#include <type_traits>
+
+namespace util {
+
+    namespace aux {
+        struct tree_erase_if_eraser {
+            template<class TreeContainer>
+            typename TreeContainer::iterator operator()(TreeContainer& cnt, typename TreeContainer::const_iterator itr) const {
+                return cnt.erase(itr);
+            }
+        };
+    }
+
+    template<class TreeContainer, class Predicate, class Eraser = aux::tree_erase_if_eraser>
+    void tree_erase_if(TreeContainer&& container, Predicate&& pred, Eraser&& eraser = Eraser{}) {
+        for (auto itr = container.begin(); itr != container.end();) {
+            if (pred(*itr)) {
+                itr = eraser(container, itr);
+            }
+            else {
+                ++itr;
+            }
+        }
+    }
+
+    namespace aux {
+
+        template<typename S, typename D>
+        struct copy_const_qual {
+            using type = D;
+        };
+
+        template<typename S, typename D>
+        struct copy_const_qual<const S, D> {
+            using type = const D;
+        };
+
+    }
+
+    template<typename E>
+    inline auto to_integral(E e) -> typename std::underlying_type<E>::type {
+        return static_cast<typename std::underlying_type<E>::type>(e);
+    }
+
+    template<
+        typename Enum,
+        typename Number = typename aux::copy_const_qual < Enum, typename std::underlying_type<Enum>::type >::type
+    >
+    inline auto to_integral_ref(Enum & e) -> Number & {
+        return reinterpret_cast<Number &>(e);
+    }
+
+    template<typename Enum, typename Integer>
+    inline auto to_enum(Integer && value) -> Enum {
+        static_assert(sizeof Enum >= sizeof Integer, "Enum should have enough room");
+        return static_cast<Enum>(value);
+    }
+
+    // Helps choose between const and non-const iterator
+    template<class ContainerType>
+    using choose_iterator = typename std::conditional< std::is_const<ContainerType>::value,
+        typename ContainerType::const_iterator, typename ContainerType::iterator>::type;
+}
diff --git a/JContainers/src/util/util.cpp b/JContainers/src/util/util.cpp
index 28abbb2..35a03dc 100644
--- a/JContainers/src/util/util.cpp
+++ b/JContainers/src/util/util.cpp
@@ -3,15 +3,17 @@
 
 namespace util {
 
+#define countof(array) sizeof(array)/(sizeof(array[0]))
+
     boost::filesystem::path dll_path() {
         HMODULE hm = nullptr;
-        bool result = GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+        auto result = GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
             GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
             (LPCSTR)&dll_path,
             &hm);
         assert(result && "GetModuleHandleExA failed");
         wchar_t path[MAX_PATH] = { '\0' };
-        GetModuleFileNameW(hm, path, sizeof path);
+        GetModuleFileNameW(hm, path, countof(path));
         return boost::filesystem::path(path);
     }
 
diff --git a/JContainers/src/util/util.h b/JContainers/src/util/util.h
index 7fc698e..89649fb 100644
--- a/JContainers/src/util/util.h
+++ b/JContainers/src/util/util.h
@@ -9,17 +9,15 @@ namespace boost { namespace filesystem {
     class path;
 }}
 
-extern void _DMESSAGE(const char * fmt, ...);
-
 namespace util {
 
     boost::filesystem::path dll_path();
     boost::filesystem::path relative_to_dll_path(const char *relative_path);
 
     template<class T>
-    void do_with_timing(const char *operation_name, T& func) {
+    void do_with_timing(const char *operation_name, T&& func) {
         assert(operation_name);
-        _DMESSAGE("%s started", operation_name);
+        JC_log("%s started", operation_name);
 
         namespace chr = std::chrono;
         auto started = chr::system_clock::now();
@@ -28,15 +26,16 @@ namespace util {
             func();
         }
         catch (const std::exception& ex) {
-            (void)ex;
+            _ERROR("'%s' throws '%s' of type '%s'", operation_name, ex.what(), typeid(ex).name());
             jc_assert(false);
         }
         catch (...) {
+            _ERROR("'%s' throws unk. exception", operation_name);
             jc_assert(false);
         }
 
         auto ended = chr::system_clock::now();
         float diff = chr::duration_cast<chr::milliseconds>(ended - started).count() / 1000.f;
-        _DMESSAGE("%s finished in %f sec", operation_name, diff);
+        JC_log("%s finished in %f sec", operation_name, diff);
     }
 }
